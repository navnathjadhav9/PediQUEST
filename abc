package org.dfci.proquest.services.impl.pediquest;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilePermission;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Map.Entry;
import java.util.ResourceBundle;
import java.util.Set;

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.dfci.proquest.domain.Answer;
import org.dfci.proquest.domain.Answer.AnswerStatus;
import org.dfci.proquest.domain.AnswerOption;
import org.dfci.proquest.domain.AnswerOptionContent;
import org.dfci.proquest.domain.AutoJobLog.JobStatus;
import org.dfci.proquest.domain.CRC;
import org.dfci.proquest.domain.Caregiver;
import org.dfci.proquest.domain.LanguageMaster;
import org.dfci.proquest.domain.ParticipantStudyStatusMaster;
import org.dfci.proquest.domain.ParticipantStudyStatusMaster.ParticipantStudyStatus;
import org.dfci.proquest.domain.Patient;
import org.dfci.proquest.domain.Person;
import org.dfci.proquest.domain.PrescribedMedication;
import org.dfci.proquest.domain.Provider;
import org.dfci.proquest.domain.Question;
import org.dfci.proquest.domain.QuestionnaireInstance;
import org.dfci.proquest.domain.ResearchSubject;
import org.dfci.proquest.domain.ResearchSubject.ResearchSubjectType;
import org.dfci.proquest.domain.RxTerm;
import org.dfci.proquest.domain.Score;
import org.dfci.proquest.domain.ScoresDetails;
import org.dfci.proquest.domain.Section;
import org.dfci.proquest.domain.Study;
import org.dfci.proquest.domain.Treatment;
import org.dfci.proquest.domain.TreatmentMaster;
import org.dfci.proquest.domain.UserRegistrationDetails.UserRegistrationMode;
import org.dfci.proquest.domain.pediquest.PediCTReports;
import org.dfci.proquest.domain.pediquest.PediCTReports.PediCTReportStatus;
import org.dfci.proquest.domain.pediquest.PediCTReportsContents;
//import org.dfci.proquest.domain.pediquest.PediCTRptSymptomEmailMetadata;
import org.dfci.proquest.domain.pediquest.PediCTRptSymptomEmailMetadata;
import org.dfci.proquest.domain.pediquest.PediCTRptSymptomGraphsMetadata;
import org.dfci.proquest.domain.pediquest.PediCTRptSymptomGraphsMetadata.PediCTReportSymptomType;
import org.dfci.proquest.domain.pediquest.PediCareTeamReportSeveritySchemes;
import org.dfci.proquest.domain.pediquest.PediResearchSubject;
import org.dfci.proquest.domain.pediquest.PediScore;
import org.dfci.proquest.domain.pediquest.PediScore.PediScoreStatus;
import org.dfci.proquest.domain.pediquest.PediScoringRule.PediSection;
import org.dfci.proquest.domain.pediquest.PediScoringRule.Respondent;
import org.dfci.proquest.domain.report.Disease_Status;
import org.dfci.proquest.domain.report.NCCCPC_R_Content;
import org.dfci.proquest.email.MailUtil;
import org.dfci.proquest.email.pediQuest.PediErrorReportToCRCEmailServices;
import org.dfci.proquest.email.pediQuest.PediReportEmailServices;
import org.dfci.proquest.persistence.CaregiverDao;
import org.dfci.proquest.persistence.LanguageMasterDao;
import org.dfci.proquest.persistence.PatientDao;
import org.dfci.proquest.persistence.PediCTReportContentsDao;
import org.dfci.proquest.persistence.ProviderDao;
import org.dfci.proquest.persistence.QuestionnaireInstanceDao;
import org.dfci.proquest.persistence.ResearchSubjectDao;
import org.dfci.proquest.persistence.RxTermDao;
import org.dfci.proquest.persistence.SectionDao;
import org.dfci.proquest.persistence.StudyDao;
import org.dfci.proquest.persistence.TreatmentMasterDao;
import org.dfci.proquest.persistence.pediquest.PediCTReportsDao;
import org.dfci.proquest.persistence.pediquest.PediCTRptSymptomEmailMetadataDao;
//import org.dfci.proquest.persistence.pediquest.PediCTRptSymptomEmailMetadataDao;
import org.dfci.proquest.persistence.pediquest.PediCTRptSymptomGraphsMetadataDao;
import org.dfci.proquest.persistence.pediquest.PediCareTeamReportSeveritySchemesDao;
import org.dfci.proquest.persistence.pediquest.PediResearchSubjectDao;
import org.dfci.proquest.persistence.pediquest.PediScoreDao;
import org.dfci.proquest.persistence.pediquest.PediScoringRuleDao;
import org.dfci.proquest.services.CRCService;
import org.dfci.proquest.services.MedicationService;
import org.dfci.proquest.services.PatientService;
import org.dfci.proquest.services.PushNotificationService;
import org.dfci.proquest.services.QuestionService;
import org.dfci.proquest.services.QuestionnaireInstanceService;
import org.dfci.proquest.services.ResearchSubjectService;
import org.dfci.proquest.services.comparator.pedireport.ScoreComparator;
import org.dfci.proquest.services.core.FunctionUtil;
import org.dfci.proquest.services.core.PushNotificationConstants;
import org.dfci.proquest.services.exception.FCMSendMessageFailed;
import org.dfci.proquest.services.exception.InconsistentDataException;
import org.dfci.proquest.services.exception.NoCRCForStudyException;
import org.dfci.proquest.services.exception.SessionIsDeactiveException;
import org.dfci.proquest.services.exception.SessionIsInactiveException;
import org.dfci.proquest.services.exception.SessionNotFoundException;
import org.dfci.proquest.services.model.pedireport.ActualMedsAndTreatments;
import org.dfci.proquest.services.model.pedireport.Allergies;
import org.dfci.proquest.services.model.pedireport.EmailRecord;
//import org.dfci.proquest.services.model.pedireport.EmailRecord;
import org.dfci.proquest.services.model.pedireport.PatientSymptomData;
import org.dfci.proquest.services.model.pedireport.PatientSymptomData.GraphTypeEnum;
import org.dfci.proquest.services.model.pedireport.PrescribedSupportivecareMeds;
import org.dfci.proquest.services.model.pedireport.ReportRecord;
import org.dfci.proquest.services.model.pedireport.SymptomPoints;
import org.dfci.proquest.services.pediquest.PediReportsService;
import org.jfree.util.Log;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PropertiesLoaderUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.opencsv.CSVWriter;
import com.opencsv.bean.ColumnPositionMappingStrategy;
import com.opencsv.bean.StatefulBeanToCsv;
import com.opencsv.bean.StatefulBeanToCsvBuilder;

import net.sf.jasperreports.engine.JRDataSource;
import net.sf.jasperreports.engine.JRExporterParameter;
import net.sf.jasperreports.engine.JRParameter;
import net.sf.jasperreports.engine.JasperFillManager;
import net.sf.jasperreports.engine.JasperPrint;
import net.sf.jasperreports.engine.data.JRBeanCollectionDataSource;
import net.sf.jasperreports.engine.export.JRPdfExporter;
import net.sf.jasperreports.engine.util.JRLoader;

@Service
public class PediReportsServiceImpl implements PediReportsService {

	@Autowired
	private PatientService patientService;

	@Autowired
	private MedicationService medicationService;

	@Autowired
	private RxTermDao rxtermDao;

	@Autowired
	private PediScoreDao pediScoreDao;

	@Autowired
	private TreatmentMasterDao treatmentMasterDao;

	@Autowired
	private PediCTRptSymptomGraphsMetadataDao symptomMetadataDao;

	@Autowired
	PediCTRptSymptomEmailMetadataDao symptomEmailMetadataDao;

	@Autowired
	private PediCareTeamReportSeveritySchemesDao severtiyDao;

	@Autowired
	private PediScoringRuleDao pediScoringRuleDao;

	@Autowired
	private CaregiverDao caregiverDao;

	@Autowired
	private ResearchSubjectService rsService;

	@Autowired
	private PediErrorReportToCRCEmailServices errorTOCRCService;

	@Autowired
	private PediReportEmailServices emailReportsService;

	@Autowired
	private QuestionService questionService;

	@Autowired
	private SectionDao sectionDao;

	@Autowired
	private QuestionnaireInstanceService questInstanceService;

	@Autowired
	private PediCTReportsDao pediCTReportsDao;

	@Autowired
	private CRCService crcService;

	@Autowired
	private PediResearchSubjectDao pediResearchSubjectDao;

	@Autowired
	private PushNotificationService pushNotificationService;

	@Autowired
	ProviderDao providerDao;

	@Autowired
	LanguageMasterDao languageMasterDao;

	@Autowired
	PediCTReportContentsDao pediCTReportContentsDao;

	@Autowired
	MessageSource messageSource;

	@Autowired
	ResearchSubjectDao researchSubjectDao;

	@Autowired
	PatientDao patientDao;

	@Autowired
	QuestionnaireInstanceDao questionnaireInstanceDao;

	@Autowired
	StudyDao studyDao;

	private static final Logger logger = LoggerFactory.getLogger(PediReportsServiceImpl.class);

	// private static String[] parentSectionCodes =
	// {"MSAS_pf","PQL2_4","PQL5_7p","PQL8_12p","PQL13_18p"};
	private static String[] parentSectionCodes = { "Diff_days", "NS", "NCCPC_R", "MSAS_pf", "WB_pf" };
	// This is used to calculate the QOL scores for the summary report. The order of
	// sections is important. Mention childs section followed by parent's section.
	// private static String[] QOLSectionCodes =
	// {"PQL2_4","PQL5_7_sr","PQL5_7p","PQL8_12","PQL8_12p","PQL13_18","PQL13_18p"};
	private static String[] QOLSectionCodes = { "Diff_days", "NS", "NCCPC_R", "MSAS_pf", "WB_pf" };
	// private static String footnoteImagePath = "C:\\pedireports_dev_v2\\";

	private static String imageBasePath = "";

	private static String ctReportExcelFileBasePath;
	private static Properties autoJobProp = null;
	static {
		try {
			Resource resource = new ClassPathResource("/autoJob.properties");
			autoJobProp = PropertiesLoaderUtils.loadProperties(resource);
			ctReportExcelFileBasePath = autoJobProp.getProperty("scheduler.ctReportExcelfile.base.path");

		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			throw new RuntimeException("Please check path of audit log file (loggerFilePath) in your web.xml", e);
		}
	}

	private static ArrayList<String> parentSections;

	class SymptomData {
		String symptomName;
		Float score;
	}

	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public Integer generatePediCareTeamReport(ResearchSubject rs, List<PediScore> pediScoreList,
			String reportPDFFolderPath) throws Exception {

		Integer reportId = null;
		/* List<ReportRecord> reportDataList = new ArrayList<ReportRecord>(); */
		ReportRecord reportData = new ReportRecord();
		Integer localeId = 1;
		Patient patient = getPatientRecord(rs);
		ResearchSubject patientRS = getPatientRSRecord(rs);
		determineTimeframe(rs, reportData, pediScoreList);
		List<Score> scores = getScores(patientRS, reportData, pediScoreList);

		// Set parental sections
		parentSections = new ArrayList<String>(Arrays.asList(parentSectionCodes));

		if (scores.size() < 1) {
			logger.debug("no scores for the patient");
			return null;
		}

		if (patientRS.getLanguagePreference() != null && patientRS.getLanguagePreference().getId() != null)
			localeId = patientRS.getLanguagePreference().getId();

		ResourceBundle bundle = ResourceBundle.getBundle("messages", new Locale("en"));

		PediCTReports report = new PediCTReports();
		logger.info("get language master rows from database");
		List<LanguageMaster> languageMasters = languageMasterDao.findAll();
		if (languageMasters != null && !languageMasters.isEmpty()) {
			logger.debug("languageMasters : " + languageMasters);
			for (LanguageMaster languageMaster : languageMasters) {
				logger.debug("Getting language code from properties file by display name : "
						+ languageMaster.getCodedEntity().getDisplayName());
				String langCode = bundle.getString(languageMaster.getCodedEntity().getDisplayName());
				List<ReportRecord> reportDataList = new ArrayList<ReportRecord>();
				logger.debug("Creating report for language : " + langCode);
				populatePatientPersonInformation(reportData, patient);
				// populateRxMedications(reportData,patient);
				// populateAllergies(reportData,patient);
				// populateMedicationsAndTreatments(reportData,patient);
				populateSymtomData(reportData, scores, patientRS, langCode);
				populatePediSummarySection(reportData, patientRS, langCode);
				reportDataList.add(reportData);
				List<EmailRecord> emailRecordList = new ArrayList<EmailRecord>();
				EmailRecord emailRecord = fetchDataForPainChecklistDomains3(reportData, scores, patientRS, langCode);
				emailRecordList.add(emailRecord);
				logger.debug("Data fetch for emailRecord" + emailRecord);

				try {
					logger.info("Calling createReport");
					PediCTReportsContents content = createReport(reportDataList, patient, patientRS, langCode,
							reportPDFFolderPath, emailRecord);
					if (content == null) {
						// Send error mail...?
					} else {
						logger.debug("content : " + content);
						logger.info("adding to report");
						report.getContents().add(content);
					}

				} catch (Exception e) {
					logger.error(
							"PEDIQUEST-ERROR: an exception has occured while creating report for ResearchSubject id = "
									+ rs.getId() + ", ");
					logger.error(e.toString());
					e.printStackTrace();

				}

			} // end of for

			report.setPatientRS(patientRS);
			String pattern = "yyyy_MM_dd_hh_mm_ss";
			SimpleDateFormat format = new SimpleDateFormat(pattern);
			Date reportDate = Calendar.getInstance().getTime();
			String reportName = patient.getPerson().getLastName() + "_" + patient.getPerson().getFirstName() + "_"
					+ reportData.getPatientMRN() + "_" + format.format(reportDate) + ".pdf";
			report.setReportName(reportName);
			report.setScoresInReport(reportData.getScoresInReport());
			report.setTimestamp_report_created(Calendar.getInstance());
			// delete Status column in table
			// //report.setStatus(PediCTReportStatus.PDFCreated);
			report = pediCTReportsDao.persist(report);
			reportId = report.getId();

			// Update status for every valid pediscore (i.e. one that satisfies the MSAS
			// criteria) associated with the Research Subject
			for (PediScore pediScore : pediScoreList) {
				if (!pediScore.isReportGenerated()) {
					pediScore.setStatusNotes(pediScore.getStatusNotes() + "CTR generated.");
					pediScore.setReportGenerated(true);
					try {
						pediScoreDao.update(pediScore);
					} catch (Exception e) {
						logger.error("PEDIQUEST-ERROR: an exception has occured while updating pediScore with id = "
								+ pediScore.getId());
					}

				}
			}

			return reportId;
		}

		logger.info("languages not found to create report.");
		logger.info("Returning null");
		return null;
	}

	private List<Score> getScores(ResearchSubject patientRS, ReportRecord reportData, List<PediScore> pediScoreList) {

		// List<Score> scores =
		// pediScoreDao.findForPatientRSScoresReadyForReports(patientRS);
		List<Score> validScores = new ArrayList<Score>();
		for (PediScore ps : pediScoreList) {
			if (ps.getScore().getQuestInstance().getEndDate().compareTo(reportData.getTimeframeStartDate()) >= 0
					&& ps.getScore().getQuestInstance().getEndDate().compareTo(reportData.getTimeframeEndDate()) <= 0) {
				validScores.add(ps.getScore());
			}
		}
		return validScores;
	}

	private void determineTimeframe(ResearchSubject rs, ReportRecord reportData, List<PediScore> pediScoreList) {

		// List<Score> scores = pediScoreDao.findAllValidScoresForRS(rs);
		// List<QuestionnaireInstance> questInstances =
		// questInstanceService.getQuestionnaireInstances(rs);

		if (pediScoreList.isEmpty()) {
			logger.debug("No Pedi Scores found for rs: " + rs.getId());
			throw new InconsistentDataException();
		}
		Date latestSurveyDate = null;
		for (PediScore ps : pediScoreList) {
			if (latestSurveyDate == null) {
				latestSurveyDate = ps.getScore().getQuestInstance().getEndDate();
				reportData.setLatestQuestInstance(ps.getScore().getQuestInstance());
				continue;
			}
			if (ps.getScore().getQuestInstance().getEndDate().after(latestSurveyDate)) {
				latestSurveyDate = ps.getScore().getQuestInstance().getEndDate();
				reportData.setLatestQuestInstance(ps.getScore().getQuestInstance());
			}
		}

		Calendar endDate = Calendar.getInstance();
		endDate.setTime(latestSurveyDate);
		Calendar startDate = Calendar.getInstance();
		startDate.setTime(latestSurveyDate);
		startDate.add(Calendar.MONTH, -3);
		endDate.add(Calendar.DAY_OF_MONTH, 1);
		reportData.setTimeframeStartDate(startDate.getTime());
		reportData.setTimeframeEndDate(endDate.getTime());
	}

	public Patient getPatientRecord(ResearchSubject rs) {
		Patient patient;
		Person person;
		if (rs.getType() == ResearchSubject.ResearchSubjectType.PATIENT) {
			person = rs.getPerson();
			List<Patient> patients = (List<Patient>) FunctionUtil.emptyIfNull(patientService.searchByCriteria(
					person.getFirstName(), person.getLastName(), null, person.getDOB(), person.getCityOfBirth(),
					rs.getStudySite().getId(), rs.getStudySite().getStudy().getStudyName()));
			if (patients.size() != 1) {
				logger.debug(patients.size() + " patient record(s) found for the research subject: " + rs.getId());
				throw new InconsistentDataException();
			}
			patient = patients.get(0);
		} else if (rs.getType() == ResearchSubject.ResearchSubjectType.CAREGIVER) {
			Caregiver cg = caregiverDao.findByPersonIdStudyId(rs.getPerson().getId(),
					rs.getStudySite().getStudy().getId());
			if (cg == null) {
				logger.debug("No caregiver record found for the research subject: " + rs.getId());
				throw new InconsistentDataException();
			}
			patient = cg.getPatient();
			if (patient == null) {
				logger.debug("No patients associated with the caregiver : " + cg.getId());
				throw new InconsistentDataException();
			}
			person = patient.getPerson();
		} else {
			logger.debug("Unsupported research subject type : " + rs.getType().toString());
			throw new InconsistentDataException();
		}
		return patient;

	}

	private ResearchSubject getPatientRSRecord(ResearchSubject rsSurvey) {
		Patient patient;
		Person person;
		ResearchSubject patientRS;
		if (rsSurvey.getType() == ResearchSubject.ResearchSubjectType.PATIENT) {
			patientRS = rsSurvey;
		} else if (rsSurvey.getType() == ResearchSubject.ResearchSubjectType.CAREGIVER) {
			ResearchSubject rs = rsSurvey;
			Caregiver cg = caregiverDao.findByPersonIdStudyId(rs.getPerson().getId(),
					rs.getStudySite().getStudy().getId());
			if (cg == null) {
				logger.debug("No caregiver record found for the research subject: " + rs.getId());
				throw new InconsistentDataException();
			}
			patient = cg.getPatient();
			if (patient == null) {
				logger.debug("No patients associated with the caregiver : " + cg.getId());
				throw new InconsistentDataException();
			}
			person = patient.getPerson();
			patientRS = rsService.findByPersonIdStudyId(person, rs.getStudySite());
			if (patientRS == null) {
				logger.debug("No research subject entry found for person Id : " + person.getId() + " in study site "
						+ rs.getStudySite().getId());
				throw new InconsistentDataException();
			}
		} else {
			logger.debug("Unsupported RS type " + rsSurvey.getType() + "for rs " + rsSurvey.getId());
			throw new InconsistentDataException();
		}
		return patientRS;

	}

	private void populatePatientPersonInformation(ReportRecord reportData, Patient patient) {
		// Personal info
		reportData.setPatientFirstName(patient.getPerson().getFirstName());
		reportData.setPatientMiddleName(patient.getPerson().getMiddleInitial());
		reportData.setPatientLastName(patient.getPerson().getLastName());
		reportData.setPatientDOB(patient.getPerson().getDOB());
		if (patient.getPatientIds().iterator().next().getPatientId().length() > 12)
			reportData.setPatientMRN(patient.getPatientIds().iterator().next().getPatientId().substring(0, 12));
		else
			reportData.setPatientMRN(patient.getPatientIds().iterator().next().getPatientId());

	}

	private void populateRxMedications(ReportRecord reportData, Patient patient) {

		// Medications
		List<PrescribedSupportivecareMeds> meds = new ArrayList<PrescribedSupportivecareMeds>();
		List<PrescribedMedication> patientRxMeds = (List<PrescribedMedication>) FunctionUtil
				.emptyIfNull(medicationService.getPrescribedMedications(patient));

		for (PrescribedMedication rx : patientRxMeds) {
			// Display all medications that have a start date but no end date or end date in
			// future. (Active)
			// if(rx.getEndDate()!=null && rx.getEndDate().after(new Date()))
			if (rx.getStartDate().before(reportData.getTimeframeEndDate())) {
				if (rx.getEndDate() != null && rx.getEndDate().before(reportData.getTimeframeStartDate())) {
				} else {
					PrescribedSupportivecareMeds med = new PrescribedSupportivecareMeds();
					List<RxTerm> rxMed = (List<RxTerm>) FunctionUtil
							.emptyIfNull(rxtermDao.searchByFullName(rx.getName()));

					if (rxMed.size() != 1)
						throw new InconsistentDataException();
					med.setGenericName(rxMed.get(0).getGenericName());
					med.setFrequency(rx.getFrequency());
					med.setQuantity(rx.getQuantity());
					med.setStartDate(rx.getStartDate());
					meds.add(med);
				}
			}
		}
		if (meds.isEmpty()) {
			// If no prescriptions found, make it null. Report will display it as "none"
			PrescribedSupportivecareMeds med = new PrescribedSupportivecareMeds();
			med.setGenericName("None");
			med.setFrequency("");
			med.setQuantity("");
			meds.add(med);
			reportData.setPrescribedSupportivecareMeds(meds);

		} else {
			// sort is alphabetically based on generic name,quantity and frequency
			Collections.sort(meds);
			reportData.setPrescribedSupportivecareMeds(meds);
		}
	}

	private void populateAllergies(ReportRecord reportData, Patient patient) {

		List<Allergies> allergies = new ArrayList<Allergies>();
		Allergies patientAllergy = new Allergies();

		if (patient.getAllergies() != null && !patient.getAllergies().isEmpty())
			patientAllergy.setAllergyName(patient.getAllergies());
		else
			patientAllergy.setAllergyName("None");

		allergies.add(patientAllergy);
		reportData.setAllergies(allergies);
	}

	private void populateMedicationsAndTreatments(ReportRecord reportData, Patient patient) {

		// Medications and Treatments
		List<ActualMedsAndTreatments> medsandtreatments = new ArrayList<ActualMedsAndTreatments>();
		String treat = "t";
		String medi = "m";

		List<ActualMedsAndTreatments> actualtreatments = new ArrayList<ActualMedsAndTreatments>();
		List<Treatment> treatments = (List<Treatment>) FunctionUtil.emptyIfNull(patient.getTreatments());

		for (Treatment t : treatments) {
			ActualMedsAndTreatments treatment = new ActualMedsAndTreatments();
			if (t.getStartDate().before(reportData.getTimeframeEndDate())) {
				if (t.getEndDate() != null && t.getEndDate().before(reportData.getTimeframeStartDate())) {
				} else {
					treatment.setName(t.getName());
					treatment.setStartDate(t.getStartDate());
					if (t.getEndDate() == null)
						treatment.setEndDate(reportData.getTimeframeEndDate());
					else
						treatment.setEndDate(t.getEndDate());
					treatment.setType(treat);
					actualtreatments.add(treatment);
				}
			}
		}

		Map<String, ActualMedsAndTreatments> treatmentsMap = new HashMap<String, ActualMedsAndTreatments>();
		for (ActualMedsAndTreatments t : medsandtreatments)
			if (!treatmentsMap.containsKey(t.getName()))
				treatmentsMap.put(t.getName(), t);

		List<TreatmentMaster> treatmentMasterList = (List<TreatmentMaster>) FunctionUtil
				.emptyIfNull(treatmentMasterDao.findAll());
		for (TreatmentMaster tm : treatmentMasterList)
			if (!treatmentsMap.containsKey(tm.getTreatmentName())) {
				// Skip 'Admitted - ICU' and 'Admitted - SCT' if those are not present
				if ((tm.getTreatmentName().compareTo("Admitted - ICU") != 0)
						&& (tm.getTreatmentName().compareTo("Admitted - SCT") != 0)) {
					ActualMedsAndTreatments treatment = new ActualMedsAndTreatments();
					treatment.setName(tm.getTreatmentName());
					treatment.setStartDate(new Date());
					treatment.setEndDate(new Date());
					treatment.setType(treat);
					actualtreatments.add(treatment);
				}
			}
		Collections.sort(actualtreatments);
		medsandtreatments.addAll(actualtreatments);

		List<ActualMedsAndTreatments> medications = new ArrayList<ActualMedsAndTreatments>();
		List<PrescribedMedication> patientRxMeds = (List<PrescribedMedication>) FunctionUtil
				.emptyIfNull(medicationService.getPrescribedMedications(patient));

		for (PrescribedMedication rx : patientRxMeds) {
			ActualMedsAndTreatments medication = new ActualMedsAndTreatments();
			List<RxTerm> rxTermRecords = (List<RxTerm>) FunctionUtil
					.emptyIfNull(rxtermDao.searchByFullName(rx.getName()));
			if (rxTermRecords.size() != 1)
				throw new InconsistentDataException();
			if (rx.getStartDate().before(reportData.getTimeframeEndDate()))
			// if(rx.getStartDate().after(reportData.getTimeframeStartDate())&&
			// rx.getStartDate().before(reportData.getTimeframeEndDate()))
			// && (rx.getEndDate()!= null &&
			// rx.getEndDate().after(timeframeStartDate.getTime())))
			{
				if (rx.getEndDate() != null && rx.getEndDate().before(reportData.getTimeframeStartDate())) {
				} else {
					medication.setName(
							rxTermRecords.get(0).getGenericName() + " " + rx.getQuantity() + " " + rx.getFrequency());
					medication.setStartDate(rx.getStartDate());
					if (rx.getEndDate() == null)
						medication.setEndDate(reportData.getTimeframeEndDate());
					else
						medication.setEndDate(rx.getEndDate());
					medication.setType(medi);
					medications.add(medication);
				}
			}
		}

		Collections.sort(medications);
		medsandtreatments.addAll(medications);
		reportData.setActualMedsAndTreatments(medsandtreatments);
	}

	private void populateSymtomData(ReportRecord reportData, List<Score> validScores, ResearchSubject patientRS,
			String languageCode) {
		List<PediCTRptSymptomGraphsMetadata> symptomlist = (List<PediCTRptSymptomGraphsMetadata>) FunctionUtil
				.emptyIfNull(symptomMetadataDao.findAll());
		Set<PatientSymptomData> patientScores = new HashSet<PatientSymptomData>();
		Map<Integer, Score> scoresInReport = new HashMap<Integer, Score>();
		reportData.setScoresInReport(new ArrayList<Score>());
		List<String> symptomsNotPresent = new ArrayList<String>();
		Set<String> newSymptoms = new HashSet<String>();
		Map<Integer, Map<String, Map<String, ScoresDetails>>> validScoresMap = new HashMap<Integer, Map<String, Map<String, ScoresDetails>>>();
		Map<String, PatientSymptomData> multiLineGraphMap = new HashMap<String, PatientSymptomData>();

		for (Score s : validScores) {
			Map<String, Map<String, ScoresDetails>> sdMap = createScoreDetailsMapForSymptom(s.getScorevalues());
			validScoresMap.put(s.getId(), sdMap);
		}

		logger.debug("Getting bundle for languageCode : " + languageCode);
		ResourceBundle bundle = null;
		bundle = ResourceBundle.getBundle("messages", new Locale(languageCode));
		if (bundle == null) {
			logger.info("bundle not loaded for above languageCode");
			logger.info("So loading for English");
			bundle = ResourceBundle.getBundle("messages", new Locale("en"));
		}

		for (PediCTRptSymptomGraphsMetadata symptom : symptomlist) {

			logger.debug("Evaluating when to show for:" + symptom.getAttributeName());
			// check if the symptom was present in last one month
			if (evaluateWhenToGraphMSASSymptom(reportData, validScores, symptom.getWhenToShow())) // here in when to
																									// show we have to
																									// tell get question
																									// function to get
																									// question from
																									// perticular
																									// section.
			{
				if (symptom.getBusinessRule() == null) {
					logger.error("No business rule found for msas symtom in CT Report metadata");
					throw new InconsistentDataException();
				}
				logger.debug("Generating points for:" + symptom.getAttributeName());
				PatientSymptomData dataForParent = new PatientSymptomData();
				dataForParent = this.populateFromSymptom(symptom, dataForParent, bundle);
				dataForParent.setSequenceNo(dataForParent.getSequenceNo() + 1);
				dataForParent.setOriginalAttributeName(bundle.getString(symptom.getAttributeName()));
				dataForParent.setAttributeName(symptom.getAttributeName() + "_P");
				dataForParent.setDisplayName(bundle.getString(symptom.getDisplayName()));

				// Constant Metadata
				PatientSymptomData dataForChild = new PatientSymptomData();
				dataForChild = this.populateFromSymptom(symptom, dataForChild, bundle);
				dataForChild.setOriginalAttributeName(bundle.getString(symptom.getAttributeName()));
				dataForChild.setAttributeName(symptom.getAttributeName() + "_C");
				dataForChild.setDisplayName(bundle.getString(symptom.getDisplayName()));

				String scoreNameInBusinessRule = symptom.getBusinessRule();
				logger.debug("Plotting graph for" + scoreNameInBusinessRule);
				for (Score s : validScores) {
					List<String> pediSectionsInSurvey = this.getPediSectionsInSurvey(s);

					for (String sectionCode : pediSectionsInSurvey) {
						Boolean isSeveritySet = Boolean.FALSE;
						PatientSymptomData data = null;
						if (parentSections.contains(sectionCode)) {
							data = dataForParent;
							data.setLatestRespondent(
									bundle.getString("report.dynamic.i18n." + Respondent.Parent.name()));
							/*
							 * if(invalidparentSurvey) { isSeveritySet = Boolean.TRUE;
							 * data.setLatestSeverity(bundle.getString("report.incomplete.survey"));
							 * data.setColorCode("NA"); data.setColorCodeValue("NA"); }
							 */
						}
						/*
						 * else { data = dataForChild; if(sectionCode.contains("_oc") ||
						 * sectionCode.contains("13_18"))
						 * data.setLatestRespondent(bundle.getString("report.dynamic.i18n."+"Teen"));
						 * else
						 * data.setLatestRespondent(bundle.getString("report.dynamic.i18n."+Respondent.
						 * Child.name()));
						 * 
						 * if(invalidChildSurvey) { isSeveritySet = Boolean.TRUE;
						 * data.setLatestSeverity(bundle.getString("report.incomplete.survey"));
						 * data.setColorCode("NA"); data.setColorCodeValue("NA"); } }
						 */

						// Data for the most recent survey
						data.setLastSurveyDate(reportData.getLatestQuestInstance().getEndDate());
						Map<String, Map<String, ScoresDetails>> sectionWiseScorevalues = validScoresMap.get(s.getId());
						Map<String, ScoresDetails> scorevalues = sectionWiseScorevalues.get(sectionCode);
						String var = scoreNameInBusinessRule;
						if (scorevalues.containsKey(var)) {
							if (scorevalues.get(var).getValue() != null && scorevalues.get(var).getValue() >= 0) {
								logger.debug("scorevalues.get(var).getValue()" + scorevalues.get(var).getValue());
								logger.debug("data" + data);
								// Add graph point
								SymptomPoints point = new SymptomPoints();
								point.setAttributeName(data.getAttributeName());
								point.setDisplayName(data.getOriginalAttributeName());
								point.setDateReported(s.getQuestInstance().getEndDate());

								if (scorevalues.get(var).getValue() > data.getHighValue())
									point.setValue(data.getHighValue().floatValue());
								else
									point.setValue(scorevalues.get(var).getValue());

//								point.setRespondent(s.getQuestInstance().getResearchSubject().getType().getName());
//													
								data.getSymptompoints().add(point);

								// Create a list of scores used in the report
								if (!scoresInReport.containsKey(s.getId())) {
									scoresInReport.put(s.getId(), s);
									reportData.getScoresInReport().add(s);
								}

								data.setLatestScore(Float.toString(scorevalues.get(var).getValue()));
								PediCareTeamReportSeveritySchemes scheme = determineSeverity(symptom, var,
										scorevalues.get(var).getValue(), sectionCode);
								if (scheme == null && !isSeveritySet) {
									data.setLatestSeverity("NA");
									data.setColorCode("NA");
									data.setColorCodeValue("NA");
								} else if (!isSeveritySet) {
									// if(symptom.getSymptomType().equals(PediCTReportSymptomType.MSASINDIVIDUAL))
									if (symptom.getSymptomType() == PediCTReportSymptomType.MSASINDIVIDUAL)
										data.setLatestSeverity(
												bundle.getString("MSASINDIVIDUAL." + scheme.getScoreSeverity()));
									else
										data.setLatestSeverity(bundle.getString(scheme.getScoreSeverity()));
									data.setColorCode(scheme.getColorcode());
									data.setColorCodeValue(scheme.getColorCodeValue());
								}
								// break;

							} else if ((scorevalues.get(var).getValue() == null)
									|| (scorevalues.get(var).getValue() < 0) && !isSeveritySet) {
								data.setLatestScore("NA");
								data.setLatestSeverity(bundle.getString("report.notanswered"));
								data.setColorCode("NA");
								data.setColorCodeValue("NA");
							}
							if (data != null && data.getSymptompoints() != null && !data.getSymptompoints().isEmpty()) {
								logger.debug(data.getSymptompoints().toString());
								// For MSAS symptoms
								// if(symptom.getSymptomType().equals(PediCTReportSymptomType.MSASINDIVIDUAL))
								if (symptom.getSymptomType() == PediCTReportSymptomType.MSASINDIVIDUAL)
								// HERE new symptoms are generated..
								// they check all past 1 months survey except the current survey the symptom
								// answer is always answered as no.
								// if yes then check in current survey if symptoms are answered as yes.
								{
									// Consider all scores excluding most recent
									if (validScores.size() > 1) {
										List<Score> allScoresButTheLast = new ArrayList<Score>();
										allScoresButTheLast.addAll(validScores);
										allScoresButTheLast.remove(allScoresButTheLast.size() - 1);

										Calendar endDate = Calendar.getInstance();
										Calendar startDate = Calendar.getInstance();
										endDate.setTime(reportData.getTimeframeEndDate());
										endDate.add(Calendar.DATE, -7);
										startDate.setTime(reportData.getTimeframeEndDate());
										startDate.add(Calendar.DATE, -14);

										// Only for symptoms that are reported as no in past week (exclude current
										// survey)
										// Both patient and parent have to answer the symptom as no to be counted as
										// answered as no in last week
										if (evaluateIfAlwaysAnswerdAsNo(reportData, allScoresButTheLast,
												symptom.getWhenToShow(), startDate, endDate)) {
											// Check if the symptom was reported as yes in the most recent
											// administration/current survey
											if (evaluateIfAnsweredAsYesInMostRecentSurvey(reportData,
													validScores.get(validScores.size() - 1), symptom.getWhenToShow())) {
												// newSymptoms.add(bundle.getString(symptom.getDisplayName()));
												if (symptom.getAttributeName().equals("POOR_APPETITE"))
													newSymptoms.add(
															bundle.getString(symptom.getDisplayName() + "_WITHOUT_BR"));
												else
													newSymptoms.add(bundle.getString(symptom.getDisplayName()));
											}
										}
									} else {
										// Check if the symptom was reported as yes in the most recent
										// administration/current survey
										if (evaluateIfAnsweredAsYesInMostRecentSurvey(reportData,
												validScores.get(validScores.size() - 1), symptom.getWhenToShow())) {
											// newSymptoms.add(bundle.getString(symptom.getDisplayName()));
											if (symptom.getAttributeName().equals("POOR_APPETITE"))
												newSymptoms.add(
														bundle.getString(symptom.getDisplayName() + "_WITHOUT_BR"));
											else
												newSymptoms.add(bundle.getString(symptom.getDisplayName()));
										}
									}
								}
//								
								// If graph is not multi line graph then add it to the list
								// Preeti:if( !(data.getGraphType() == GraphTypeEnum.Multi.getTypeName())){
								if (data.getGraphType() != null
										&& !data.getGraphType().equals(GraphTypeEnum.Multi.getTypeName())) {
									patientScores.add(data);
								} else {

									String key = null;

									/*
									 * if(symptom.getSymptomType().equals(PediCTReportSymptomType.QOL) ){
									 * if(parentSections.contains(sectionCode)) key = "QOL_P"; else key= "QOL_C";
									 * }else if(symptom.getSymptomType().equals(PediCTReportSymptomType.MSASTOTAL)){
									 * if(parentSections.contains(sectionCode)) key = "MSAS_P"; else key= "MSAS_C";
									 * }else{
									 */
									key = data.getAttributeName();
									// }

									/*
									 * if(symptom.getSymptomType() == PediCTReportSymptomType.QOL ){ key = "QOL";
									 * }else if(symptom.getSymptomType() == PediCTReportSymptomType.MSASTOTAL){ key
									 * = "MSAS"; }else{ key = data.getAttributeName(); }
									 */

									if (multiLineGraphMap.containsKey(key)) {
										// Do not show color for score while plotting multiline graph, Hence set
										// colorcode to NA
										data.setColorCode("NA");
										data.setColorCodeValue("NA");
										multiLineGraphMap.get(key).getSymptompoints().addAll(data.getSymptompoints());
									} else {
										data.setColorCode("NA");
										data.setColorCodeValue("NA");
										multiLineGraphMap.put(key, data);
									}
								}

							}
						}

					} // Loop for sections in score
						// Add data to report
				} // Loop for scores
			} else
			// Symptom is not present in past month
			{
				Calendar endDate = Calendar.getInstance();
				Calendar startDate = Calendar.getInstance();
				;
				endDate.setTime(reportData.getTimeframeEndDate());
				startDate.setTime(reportData.getTimeframeEndDate());
				startDate.add(Calendar.MONTH, -1);
				logger.debug("when to show is false for:" + symptom.getAttributeName());
				// check if this is an MSAS symptom
				if (symptom.getSymptomType().equals(PediCTReportSymptomType.MSASINDIVIDUAL)
						&& evaluateIfAlwaysAnswerdAsNo(reportData, validScores, symptom.getWhenToShow(), startDate,
								endDate)) {
					/*
					 * if (symptom.getAttributeName().equals("POOR_APPETITE"))
					 * symptomsNotPresent.add(bundle.getString(symptom.getAttributeName() +
					 * "_WITHOUT_BR")); else
					 */
					symptomsNotPresent.add(bundle.getString(symptom.getAttributeName()));
				}
			}
		}

		if (multiLineGraphMap.size() > 0) {

			// Add all patient Symptom data to patient Scores
			for (Map.Entry<String, PatientSymptomData> entry : multiLineGraphMap.entrySet()) {
				if (entry.getValue() != null) {
					patientScores.add(entry.getValue());
				}
			}
		}

		if (!patientScores.isEmpty()) {
			logger.debug(patientScores.toString());
			List<PatientSymptomData> dataList = new ArrayList<PatientSymptomData>();
			dataList.addAll(patientScores);
			Collections.sort(dataList);
			reportData.setPatientSymptomData(dataList);
		} else
			reportData.setPatientSymptomData(null);
		reportData.setSymptomMetadata(symptomlist);
		reportData.setSymptomsNotPresent(symptomsNotPresent);
//		reportData.setScoresInReport(new ArrayList<Score>(scoresInReport.values()));

		// Sort report data in order of evaluation time, So that it will be correctly
		// used in Report Summary Section.
		Collections.sort(reportData.getScoresInReport(), new ScoreComparator());

		List<String> newSymptomsList = new ArrayList<String>();
		newSymptomsList.addAll(newSymptoms);

		logger.info("Sort new symptom list alphabetically");
		logger.debug("New symptom list before sorting : " + newSymptomsList);
		Collections.sort(newSymptomsList, new Comparator<String>() {
			public int compare(String s1, String s2) {
				return s1.compareToIgnoreCase(s2);
			}
		});

		// TODO : Add other symmptoms list to newSymptomsList here

		logger.debug("New symptom list after sorting : " + newSymptomsList);

		reportData.setNewSymptoms(newSymptomsList);
		logger.debug("reportData:" + reportData);
	}

	private boolean isIncomplete(QuestionnaireInstance parentInstance) {
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(parentInstance.getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			if (pScore.getStatus() == PediScoreStatus.INCOMPLETESURVEY) {
				return Boolean.TRUE;
			}
		} else {
			throw new InconsistentDataException();
		}

		return Boolean.FALSE;
	}

	/*
	 * private boolean isChildInstanceIncomplete(QuestionnaireInstance
	 * childInstance) { List<PediScore> pediScores =
	 * pediScoreDao.findPediScoreForQuestionniareInstance(childInstance.getId());
	 * if(pediScores.size()==1 && pediScores.get(0)!=null) { PediScore pScore =
	 * pediScores.get(0); if(pScore.getStatus() == PediScoreStatus.INCOMPLETESURVEY)
	 * { return Boolean.TRUE; } } else { throw new InconsistentDataException(); }
	 * 
	 * return Boolean.FALSE; }
	 */

	private QuestionnaireInstance getOtherPartyLatestInstance(QuestionnaireInstance instace, Boolean isChildInstance) {
		List<String> questionnaireCodes = new ArrayList<String>();
		questionnaireCodes.add("PQ2-4");
		questionnaireCodes.add("PQ5-6");
		questionnaireCodes.add("PQ7");
		questionnaireCodes.add("PQ8-12");
		questionnaireCodes.add("PQ8-12p");
		questionnaireCodes.add("PQ13plus");
		questionnaireCodes.add("PQ13plusp");

		logger.info("In getOtherPartyLatestInstance");
		logger.debug("instanceId : " + instace.getId() + " isChildInstance : " + isChildInstance);
		List<QuestionnaireInstance> otherPartyInstances = null;
		ResearchSubject patientRS = null;
		if (isChildInstance) {
			logger.info("Get caegiver");
			ResearchSubject careGiverRS = getActiveCaregiverForPatient(instace.getResearchSubject());
			logger.debug("Get caregiver instance. careGiverRS Id : " + careGiverRS.getId());
			otherPartyInstances = questionnaireInstanceDao.instanceByRsAndAssignDate(careGiverRS,
					instace.getAssignedDate(), questionnaireCodes);
			logger.debug("otherPartyInstances : " + otherPartyInstances);
		} else {
			logger.info("Get patient");
			patientRS = this.getPatientForCaregiver(instace.getResearchSubject());
			logger.debug("Get patient instance. patientRS Id : " + patientRS.getId() + " And ageGroup : "
					+ patientRS.getAgeGroup().getName());
			otherPartyInstances = questionnaireInstanceDao.instanceByRsAndAssignDate(patientRS,
					instace.getAssignedDate(), questionnaireCodes);
		}

		if (isChildInstance) {
			if (instace.getResearchSubject().getAgeGroup().getId() > 3
					&& (otherPartyInstances == null || otherPartyInstances.size() > 1)) {
				logger.error(
						"Throwing inconsisting data exception. PARENT INSTANCE - Either otherPartyInstance is null or greater then 1");
				throw new InconsistentDataException();
			}
		} else {
			if (patientRS.getAgeGroup().getId() > 3
					&& (otherPartyInstances == null || otherPartyInstances.size() > 1)) {
				logger.error(
						"Throwing inconsisting data exception. CHILD INSTANCE - Either otherPartyInstance is null or greater then 1");
				throw new InconsistentDataException();
			}
		}

		if (otherPartyInstances == null) {
			logger.info("otherPartyInstances is null. Return null");
			return null;
		}

		logger.debug("Returning otherPartyInstances : " + otherPartyInstances.toString());
		return otherPartyInstances.get(0);
	}

	private QuestionnaireInstance determineCounterPartSurvey(Score s) {
		Score counterPartScore = null;
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(s.getQuestInstance().getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			counterPartScore = pScore.getCounterPartScore();
			if (counterPartScore != null)
				return counterPartScore.getQuestInstance();
		}

		return null;
	}

	PatientSymptomData populateFromSymptom(PediCTRptSymptomGraphsMetadata symptom, PatientSymptomData data,
			ResourceBundle bundle) {
		data.setColorCode("NA");
		data.setColorCodeValue("NA");
		data.setLatestScore("NA");
		data.setLatestSeverity(bundle.getString("report.notapplicable"));
		data.setHighValue(symptom.getHighValue());
		data.setLowValue(symptom.getLowValue());
		data.setPeriod(bundle.getString(symptom.getPeriod()));
		data.setScale(symptom.getScale());
		data.setSequenceNo(symptom.getSequenceNo() * 100);
		data.setSymptompoints(new ArrayList<SymptomPoints>());
		GraphTypeEnum graphType;

		// If it's sub-score then set graphType to Multi else set graphType to Single
		if (symptom.getSymptomType() == PediCTReportSymptomType.Pain_Checklist_Domains3) {
			if (!symptom.getAttributeName().equals("Pain_Checklist_Domains3")
					&& !symptom.getAttributeName().equals("Pain_Checklist_Domains3")) {
				graphType = GraphTypeEnum.Multi;
			} else {
				graphType = GraphTypeEnum.Single;
			}
		} else {
			graphType = GraphTypeEnum.Single;
		}
		data.setGraphType(graphType.getTypeName());
		data.setAttributeName(bundle.getString(symptom.getAttributeName()));

		return data;

	}

	// If either patient or parent answers the question as yes, the symptom is
	// counted as yes
	private Boolean evaluateIfAnsweredAsYesInMostRecentSurvey(ReportRecord reportData, Score s, String whenToShow) {

		if (whenToShow == null || whenToShow.isEmpty())
			return Boolean.TRUE;

		Boolean symptomPresent = Boolean.FALSE;
		Calendar startDate = Calendar.getInstance();
		Calendar endDate = Calendar.getInstance();
		endDate.setTime(reportData.getTimeframeEndDate());
		startDate.setTime(reportData.getTimeframeEndDate());
		startDate.add(Calendar.MONTH, -1);
		Integer start = whenToShow.indexOf("(");
		Integer end = whenToShow.indexOf(")");
		String rule = whenToShow.substring(start + 1, end);
		String[] scoreNamesInRule = rule.split(";");

		String ageGroupName = null;

		ResearchSubject patientRs = null;
		if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.CAREGIVER) == 0) {
			patientRs = getPatientForCaregiver(s.getQuestInstance().getResearchSubject());
			ageGroupName = patientRs.getAgeGroup().getName();
		} else {
			patientRs = s.getQuestInstance().getResearchSubject();
			ageGroupName = patientRs.getAgeGroup().getName();
		}

		if (whenToShow.contains("ifAnsweredYes")) {
			for (String scorenameInRule : scoreNamesInRule) {
				// if the agroup is 2-4 or 5-6
				// if(ageGroupName.contains("2 to 4") || ageGroupName.contains("5 to 6")){
				symptomPresent = determineSymptomPresent2_4And5_6(scorenameInRule, s);
				/*
				 * }else if(ageGroupName.contains("7")){ symptomPresent =
				 * determineSymptomPresent7(scorenameInRule,s); }else
				 * if(ageGroupName.contains("8 to 12")){ symptomPresent =
				 * determineSymptomPresent8_12(scorenameInRule,s); }else{ symptomPresent =
				 * determineSymptomPresent13(scorenameInRule,s); }
				 */
				if (symptomPresent)
					return symptomPresent;
			}
		}
		return symptomPresent;

	}

	private ResearchSubject getPatientForCaregiver(ResearchSubject researchSubject) {
		ResearchSubject activeRPPatient = null;

		Caregiver caregiver = caregiverDao.findByPersonIdStudyId(researchSubject.getPerson().getId(),
				researchSubject.getStudySite().getStudy().getId());
		if (caregiver != null) {
			Patient patient = caregiver.getPatient();
			if (patient != null) {
				List<ResearchSubject> patientRSList = researchSubjectDao.findByPersonIdStudyId(
						patient.getPerson().getId(), researchSubject.getStudySite().getStudy().getId());
				if (patientRSList != null) {
					activeRPPatient = patientRSList.get(0);
				} else
					throw new InconsistentDataException();
			}
		}

		return activeRPPatient;
	}

	// Both patient and parent have to answer the survey as no to count it as always
	// answered as no in given time frame (startDate to endDate)
	private Boolean evaluateIfAlwaysAnswerdAsNo(ReportRecord reportData, List<Score> scores, String whenToShow,
			Calendar startDate, Calendar endDate) {

		if (whenToShow == null || whenToShow.isEmpty())
			return Boolean.TRUE;

		Boolean symptomAlwaysAnsweredAsNo = Boolean.TRUE;
		Boolean symptomAnsweredAsNoForThisRound = Boolean.TRUE;
		Date whenToGraphStartDate = startDate.getTime();
		Date whenToGraphEndDate = endDate.getTime();
		Integer start = whenToShow.indexOf("(");
		Integer end = whenToShow.indexOf(")");
		String rule = whenToShow.substring(start + 1, end);
		String[] scoreNamesInRule = rule.split(";");

		if (whenToShow.contains("ifAnsweredYes")) {
			// Iterate through all the scores for the subject
			for (Score s : scores) {

				// If the score is evaluated in given time frame
				if (s.getQuestInstance().getEndDate().compareTo(whenToGraphStartDate) >= 0
						&& s.getQuestInstance().getEndDate().compareTo(whenToGraphEndDate) <= 0) {
					String ageGroupName = null;

					ResearchSubject patientRs = null;
					if (s.getQuestInstance().getResearchSubject().getType()
							.compareTo(ResearchSubjectType.CAREGIVER) == 0) {
						patientRs = getPatientForCaregiver(s.getQuestInstance().getResearchSubject());
						ageGroupName = patientRs.getAgeGroup().getName();
					} else {
						patientRs = s.getQuestInstance().getResearchSubject();
						ageGroupName = patientRs.getAgeGroup().getName();
					}

					for (String scorenameInRule : scoreNamesInRule) {
						// if the agroup is 2-4 or 5-6
						if (ageGroupName.contains("1 to 4") || ageGroupName.contains("5 to 9")
								|| ageGroupName.contains("10 to 14") || ageGroupName.contains("15 and above")) {
							symptomAnsweredAsNoForThisRound = determineSymptomNotPresent2_4And5_6(scorenameInRule, s);

						}
						if (!symptomAnsweredAsNoForThisRound)
							return Boolean.FALSE;
					}

					/*
					 * for (String scorenameInRule : scoreNamesInRule) { // if the agroup is 2-4 or
					 * 5-6 if (ageGroupName.contains("2 to 4") || ageGroupName.contains("5 to 6")) {
					 * symptomAnsweredAsNoForThisRound =
					 * determineSymptomNotPresent2_4And5_6(scorenameInRule, s); } else if
					 * (ageGroupName.contains("7")) { symptomAnsweredAsNoForThisRound =
					 * determineSymptomNotPresent7(scorenameInRule, s); } else if
					 * (ageGroupName.contains("8 to 12")) { symptomAnsweredAsNoForThisRound =
					 * determineSymptomNotPresent8_12(scorenameInRule, s); } else {
					 * symptomAnsweredAsNoForThisRound =
					 * determineSymptomNotPresent13(scorenameInRule, s); } if
					 * (!symptomAnsweredAsNoForThisRound) return Boolean.FALSE; }
					 */

				}

			}
		}
		return symptomAlwaysAnsweredAsNo;

	}

	private Boolean determineSymptomNotPresent13(String scorenameInRule, Score s) {
		Question q = null;
		String selectedSectionCode = null;
		Boolean symptomAnsweredAsNo = Boolean.FALSE;

		if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
			selectedSectionCode = "MSAS_oc";
		} else {
			selectedSectionCode = "MSAS_pf";
		}
		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
					logger.debug("Symptom is answered as no by first party" + scorenameInRule);
				} else {
					return symptomAnsweredAsNo;
				}
			} else {
				return symptomAnsweredAsNo;
			}

			if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
				selectedSectionCode = "MSAS_pf";
			} else {
				selectedSectionCode = "MSAS_oc";
			}
			Score counterPartScore = null;
			List<PediScore> pediScores = pediScoreDao
					.findPediScoreForQuestionniareInstance(s.getQuestInstance().getId());
			if (pediScores.size() == 1 && pediScores.get(0) != null) {
				PediScore pScore = pediScores.get(0);
				counterPartScore = pScore.getCounterPartScore();
			}

			// Counter part score could be null if the other party submitted incompelte
			// survey
			if (counterPartScore != null) {
				try {
					q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
							counterPartScore.getQuestInstance().getQuestionnaire().getMainContainer().getId());
				} catch (Exception e) {
					logger.debug("question with abbreviation" + scorenameInRule + "not found in section"
							+ selectedSectionCode);
				}
				if (q != null) {
					answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(), q);
					if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
							&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
						if (Integer
								.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
							symptomAnsweredAsNo = Boolean.TRUE;
							logger.debug("Symptom is answered as no by both parties " + scorenameInRule);
							return symptomAnsweredAsNo;
						}
					}
				}
			}

		}

		return symptomAnsweredAsNo;
	}

	private Boolean determineSymptomNotPresent8_12(String scorenameInRule, Score s) {
		Question q = null;
		String selectedSectionCode = null;
		Boolean symptomAnsweredAsNo = Boolean.FALSE;

		if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
			selectedSectionCode = "MSAS_yc";
		} else {
			selectedSectionCode = "MSAS_pf";
		}

		Boolean isParentsQuestionOnly = isParentQuestionOnly(scorenameInRule);

		Score counterPartScore = null;
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(s.getQuestInstance().getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			counterPartScore = pScore.getCounterPartScore();
		}

		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
					if (selectedSectionCode.equals("MSAS_pf") && isParentsQuestionOnly)
						return symptomAnsweredAsNo = Boolean.TRUE;
					else
						logger.debug("Symptom is answered as no by first party" + scorenameInRule);
				} else {
					return symptomAnsweredAsNo;
				}
			} else {
				return symptomAnsweredAsNo;
			}

			if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
				selectedSectionCode = "MSAS_pf";
			} else {
				selectedSectionCode = "MSAS_yc";
			}

			// Counter part score could be null if the other party submitted incomplete
			// survey
			if (counterPartScore != null) {
				try {
					q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
							counterPartScore.getQuestInstance().getQuestionnaire().getMainContainer().getId());
				} catch (Exception e) {
					logger.debug("question with abbreviation" + scorenameInRule + "not found in section"
							+ selectedSectionCode);
				}
				if (q != null) {
					answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(), q);
					if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
							&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
						if (Integer
								.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
							symptomAnsweredAsNo = Boolean.TRUE;
							logger.debug("Symptom is answered as no by both parties " + scorenameInRule);
							return symptomAnsweredAsNo;
						}
					}
				}
			}
		} else if (counterPartScore != null) {
			if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
				selectedSectionCode = "MSAS_pf";
			} else {
				selectedSectionCode = "MSAS_yc";
			}
			try {
				q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
						counterPartScore.getQuestInstance().getQuestionnaire().getMainContainer().getId());
			} catch (Exception e) {
				logger.debug(
						"question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
			}
			if (q != null) {
				Answer answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(), q);
				if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
						&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
					if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
						symptomAnsweredAsNo = Boolean.TRUE;
						logger.debug("Symptom is present" + scorenameInRule);
						return symptomAnsweredAsNo;
					}
				}
			}
		}

		return symptomAnsweredAsNo;
	}

	private Boolean isParentQuestionOnly(String scorenameInRule) {
		if (scorenameInRule.equals("MSAS_pain") || scorenameInRule.equals("MSAS_fatigue")
				|| scorenameInRule.equals("MSAS_naus") || scorenameInRule.equals("MSAS_sleep")
				|| scorenameInRule.equals("MSAS_sad") || scorenameInRule.equals("MSAS_worry")
				|| scorenameInRule.equals("MSAS_dysp") || scorenameInRule.equals("MSAS_anorex"))
			return Boolean.FALSE;

		return Boolean.TRUE;
	}

	private Boolean determineSymptomNotPresent7(String scorenameInRule, Score s) {
		Question q = null;
		String selectedSectionCode = "MSAS_pf";
		Boolean symptomAnsweredAsNo = Boolean.FALSE;

		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}

		Boolean isParentsQuestionOnly = isParentQuestionOnly(scorenameInRule);

		if (q != null) {
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
					if (isParentsQuestionOnly)
						return symptomAnsweredAsNo = Boolean.TRUE;
					else
						logger.debug("Symptom is answered as no by first party" + scorenameInRule);
				} else {
					return symptomAnsweredAsNo;
				}
			} else {
				return symptomAnsweredAsNo;
			}
			selectedSectionCode = "MSAS_yc";
			try {
				q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
						s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
			} catch (Exception e) {
				logger.debug(
						"question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
			}
			if (q != null) {
				answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
				if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
						&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
					if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
						symptomAnsweredAsNo = Boolean.TRUE;
						logger.debug("Symptom is present by both parties" + scorenameInRule);
						return symptomAnsweredAsNo;
					}
				}
			}

		}

		return symptomAnsweredAsNo;
	}

	private Boolean determineSymptomNotPresent2_4And5_6(String scorenameInRule, Score s) {

		Question q = null;
		Boolean symptomAnsweredAsNo = Boolean.FALSE;
		String selectedSectionCode = "MSAS_pf";
		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 0) {
					symptomAnsweredAsNo = Boolean.TRUE;
					logger.debug("Symptom is present" + scorenameInRule);
					return symptomAnsweredAsNo;
				}
			}
		}

		return symptomAnsweredAsNo;
	}

	// If either of patient and parent answer the question as yes in past 1 month
	// then the symptom is counted as yes.
	private Boolean evaluateWhenToGraphMSASSymptom(ReportRecord reportData, List<Score> scores, String whenToShow) {

		if (whenToShow == null || whenToShow.isEmpty())
			return Boolean.TRUE;

		Boolean symptomPresent = Boolean.FALSE;
		Calendar startDate = Calendar.getInstance();
		Calendar endDate = Calendar.getInstance();
		endDate.setTime(reportData.getTimeframeEndDate());
		startDate.setTime(reportData.getTimeframeEndDate());
		startDate.add(Calendar.MONTH, -1);
		Date whenToGraphStartDate = startDate.getTime();
		Date whenToGraphEndDate = endDate.getTime();
		Integer start = whenToShow.indexOf("(");
		Integer end = whenToShow.indexOf(")");
		String rule = whenToShow.substring(start + 1, end);
		String[] scoreNamesInRule = rule.split(";");

		if (whenToShow.contains("ifAnsweredYes") && whenToShow.contains("MSAS")) {
			// Iterate through all the scores for the subject
			for (Score s : scores) {
				// If the score is evaluated in last month
				if (s.getQuestInstance().getEndDate().compareTo(whenToGraphStartDate) >= 0
						&& s.getQuestInstance().getEndDate().compareTo(whenToGraphEndDate) <= 0) {
					String ageGroupName = null;

					ResearchSubject patientRs = null;
					if (s.getQuestInstance().getResearchSubject().getType()
							.compareTo(ResearchSubjectType.CAREGIVER) == 0) {
						patientRs = getPatientForCaregiver(s.getQuestInstance().getResearchSubject());
						ageGroupName = patientRs.getAgeGroup().getName();
					}
					/*
					 * else{ patientRs = s.getQuestInstance().getResearchSubject(); ageGroupName =
					 * patientRs.getAgeGroup().getName(); }
					 */

					for (String scorenameInRule : scoreNamesInRule) {
						// if the agroup is 2-4 or 5-6
						// if(ageGroupName.contains("2 to 4") || ageGroupName.contains("5 to 6")){
						symptomPresent = determineSymptomPresent2_4And5_6(scorenameInRule, s);
						/*
						 * }else if(ageGroupName.contains("7")){ symptomPresent =
						 * determineSymptomPresent7(scorenameInRule,s); }else
						 * if(ageGroupName.contains("8 to 12")){ symptomPresent =
						 * determineSymptomPresent8_12(scorenameInRule,s); }else{ symptomPresent =
						 * determineSymptomPresent13(scorenameInRule,s); }
						 */
						if (symptomPresent)
							return symptomPresent;
					}
				}
			} // Iterate through all scores
		} // If there is condition to evaluate when to show
		logger.debug("When to show is true for:" + whenToShow);
		return symptomPresent;

	}

	// For 8-12 check if question is in child survey and also in parent survey
	private Boolean determineSymptomPresent8_12(String scorenameInRule, Score s) {
		Question q = null;
		String selectedSectionCode = null;
		Boolean symptomPresent = Boolean.FALSE;

		if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
			selectedSectionCode = "MSAS_yc";
		} else {
			selectedSectionCode = "MSAS_pf";
		}

		Score counterPartScore = null;
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(s.getQuestInstance().getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			counterPartScore = pScore.getCounterPartScore();
		}

		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Boolean checkInCoutnerPart = Boolean.FALSE;
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
					symptomPresent = Boolean.TRUE;
					logger.debug("Symptom is present" + scorenameInRule);
					return symptomPresent;
				} else {
					checkInCoutnerPart = Boolean.TRUE;
				}
			} else {
				checkInCoutnerPart = Boolean.TRUE;
			}

			if (checkInCoutnerPart) {
				if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
					selectedSectionCode = "MSAS_pf";
				} else {
					selectedSectionCode = "MSAS_yc";
				}

				// counter part can be null if the other party did not complete the survey
				// enough - did not match msas criteria. In that case
				// declare that the symptom is not present
				if (counterPartScore != null) {
					try {
						q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
								counterPartScore.getQuestInstance().getQuestionnaire().getMainContainer().getId());
					} catch (Exception e) {
						logger.debug("question with abbreviation" + scorenameInRule + "not found in section"
								+ selectedSectionCode);
					}
					if (q != null) {
						answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(),
								q);
						if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
								&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
							if (Integer.valueOf(
									answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
								symptomPresent = Boolean.TRUE;
								logger.debug("Symptom is present" + scorenameInRule);
								return symptomPresent;
							}
						}
					}
				}

			}
		} else if (counterPartScore != null) {
			if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
				selectedSectionCode = "MSAS_pf";
			} else {
				selectedSectionCode = "MSAS_yc";
			}
			try {
				q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
						counterPartScore.getQuestInstance().getQuestionnaire().getMainContainer().getId());
			} catch (Exception e) {
				logger.debug(
						"question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
			}
			if (q != null) {
				Answer answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(), q);
				if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
						&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
					if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
						symptomPresent = Boolean.TRUE;
						logger.debug("Symptom is present" + scorenameInRule);
						return symptomPresent;
					}
				}
			}
		}
		return symptomPresent;
	}

	private Boolean determineSymptomPresent13(String scorenameInRule, Score s) {
		Question q = null;
		String selectedSectionCode = null;
		Boolean symptomPresent = Boolean.FALSE;

		if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
			selectedSectionCode = "MSAS_oc";
		} else {
			selectedSectionCode = "MSAS_pf";
		}
		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Boolean checkInCoutnerPart = Boolean.FALSE;
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
					symptomPresent = Boolean.TRUE;
					logger.debug("Symptom is present" + scorenameInRule);
					return symptomPresent;
				} else {
					checkInCoutnerPart = Boolean.TRUE;
				}
			} else {
				checkInCoutnerPart = Boolean.TRUE;
			}

			if (checkInCoutnerPart) {
				if (s.getQuestInstance().getResearchSubject().getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
					selectedSectionCode = "MSAS_pf";
				} else {
					selectedSectionCode = "MSAS_oc";
				}
				Score counterPartScore = null;
				List<PediScore> pediScores = pediScoreDao
						.findPediScoreForQuestionniareInstance(s.getQuestInstance().getId());
				if (pediScores.size() == 1 && pediScores.get(0) != null) {
					PediScore pScore = pediScores.get(0);
					counterPartScore = pScore.getCounterPartScore();
				}
				// counter part can be null if the other party did not complete the survey
				// enough - did not match msas criteria. In that case
				// declare that the symptom is not present

				if (counterPartScore != null) {
					try {
						q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
								counterPartScore.getQuestInstance().getQuestionnaire().getMainContainer().getId());
					} catch (Exception e) {
						logger.debug("question with abbreviation" + scorenameInRule + "not found in section"
								+ selectedSectionCode);
					}
					if (q != null) {
						answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(),
								q);
						if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
								&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
							if (Integer.valueOf(
									answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
								symptomPresent = Boolean.TRUE;
								logger.debug("Symptom is present" + scorenameInRule);
								return symptomPresent;
							}
						}
					}
				}
			}
		}

		return symptomPresent;
	}

	// For 7 age agroup the MSAS question can be present in two sections MSAS-pf or
	// MSAS_yc
	private Boolean determineSymptomPresent7(String scorenameInRule, Score s) {
		Question q = null;
		String selectedSectionCode = "MSAS_pf";
		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Boolean checkInCoutnerPart = Boolean.FALSE;
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
					Boolean symptomPresent = Boolean.TRUE;
					logger.debug("Symptom is present" + scorenameInRule);
					return symptomPresent;
				} else {
					checkInCoutnerPart = Boolean.TRUE;
				}
			} else {
				checkInCoutnerPart = Boolean.TRUE;
			}

			if (checkInCoutnerPart) {
				selectedSectionCode = "MSAS_yc";
				try {
					q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
							s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
				} catch (Exception e) {
					logger.debug("question with abbreviation" + scorenameInRule + "not found in section"
							+ selectedSectionCode);
				}
				if (q != null) {
					answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
					if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED
							&& answer.getOptionChoosen() != null && answer.getOptionChoosen().size() == 1) {
						if (Integer
								.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
							Boolean symptomPresent = Boolean.TRUE;
							logger.debug("Symptom is present" + scorenameInRule);
							return symptomPresent;
						}
					}
				}
			}
		}

		return Boolean.FALSE;
	}

	// For 2-4 only MSAS_pf section is applicable
	private Boolean determineSymptomPresent2_4And5_6(String scorenameInRule, Score s) {

		Question q = null;
		String selectedSectionCode = "MSAS_pf";
		try {
			q = questionService.getQuestionByCodeForSection(scorenameInRule, selectedSectionCode,
					s.getQuestInstance().getQuestionnaire().getMainContainer().getId());
		} catch (Exception e) {
			logger.debug("question with abbreviation" + scorenameInRule + "not found in section" + selectedSectionCode);
		}
		if (q != null) {
			Answer answer = questInstanceService.getLatestAnswerforQuestion(s.getQuestInstance(), q);
			if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED && answer.getOptionChoosen() != null
					&& answer.getOptionChoosen().size() == 1) {
				if (Integer.valueOf(answer.getOptionChoosen().iterator().next().getHl7Entity().getValue()) == 1) {
					Boolean symptomPresent = Boolean.TRUE;
					logger.debug("Symptom is present" + scorenameInRule);
					return symptomPresent;
				}
			}
		}

		return Boolean.FALSE;
	}

	private List<String> getPediSectionsInSurvey(Score score) {
//		Integer quizContainerId = instance.getQuestionnaire().getMainContainer().getId();
//		List<Section> sections = sectionDao.searchByQuizContainerId(quizContainerId);

		Set<String> pediSections = new HashSet<String>();
		for (ScoresDetails sd : score.getScorevalues()) {
			String serachSectionCode = sd.getSectionCode();
			serachSectionCode = serachSectionCode.replace("-", "_");
			if (isInEnum(serachSectionCode, PediSection.class)) {
				pediSections.add(serachSectionCode);
			}
		}
		logger.debug("PediSEctions in the survey are:" + pediSections);
		List<String> uniqueSectionCodes = new ArrayList<String>();
		uniqueSectionCodes.addAll(pediSections);
		return uniqueSectionCodes;
	}

	private List<String> getMSASSectionsInSurvey(QuestionnaireInstance instance) {
		Integer quizContainerId = instance.getQuestionnaire().getMainContainer().getId();
		List<Section> sections = sectionDao.searchByQuizContainerId(quizContainerId);

		ArrayList<String> msasSections = new ArrayList<String>();
		if (sections == null) {
			logger.debug("No in the survey");
			return msasSections;
		} else {
			for (Section sect : sections) {
				if (isInEnum(sect.getHl7Entity().getCode(), PediSection.class)
						&& sect.getHl7Entity().getCode().contains("MSAS")) {
					msasSections.add(sect.getHl7Entity().getCode());
				}
			}
		}
		logger.debug("MSAS in the survey are:" + msasSections);
		return msasSections;
	}

	public <E extends Enum<E>> boolean isInEnum(String value, Class<E> enumClass) {
		for (E e : enumClass.getEnumConstants()) {
			if (e.name().equals(value)) {
				return true;
			}
		}
		return false;
	}

	private PediCareTeamReportSeveritySchemes determineSeverity(PediCTRptSymptomGraphsMetadata symptom,
			String scoreName, Float value, String sectionCode) {

		List<PediCareTeamReportSeveritySchemes> scheme = null;

		/*
		 * if(scoreName.contains("avg")){ if(sectionCode.contains("MSAS_yc"))
		 * scheme=severtiyDao.findByScheme("MSASYC"); else{
		 * scheme=severtiyDao.findByScheme("MSASNONYC"); } }else
		 * if(scoreName.contains("msas_")){ if(sectionCode.contains("MSAS_yc"))
		 * scheme=severtiyDao.findByScheme("MSASYCTOTAL"); else{
		 * scheme=severtiyDao.findByScheme("MSASTotal"); } } else
		 */
		// In case of qol or MSAS physica or psycological
		scheme = severtiyDao.findByScheme(symptom.getScheme());

		if (scheme == null)
			return null;

		for (PediCareTeamReportSeveritySchemes s : scheme) {
			if (value >= s.getScoreLowValue() && value <= s.getScoreHighValue())
				return s;
		}
		System.out.print("Score does not fit in the severity range." + symptom.getDisplayName() + ":" + value);
		throw new InconsistentDataException();
	}

	private Map<String, Map<String, ScoresDetails>> createScoreDetailsMapForSymptom(List<ScoresDetails> scorevalues) {
		Map<String, Map<String, ScoresDetails>> sectionWiseScoreNames = new HashMap<String, Map<String, ScoresDetails>>();

		for (ScoresDetails sd : scorevalues) {
			String sectionCode = sd.getSectionCode().replace("-", "_");
			Map<String, ScoresDetails> scoreValuesMapForSection = sectionWiseScoreNames.get(sectionCode);
			if (scoreValuesMapForSection == null) {
				scoreValuesMapForSection = new HashMap<String, ScoresDetails>();
			}
			scoreValuesMapForSection.put(sd.getScoreName(), sd);
			sectionWiseScoreNames.put(sectionCode, scoreValuesMapForSection);
		}
		return sectionWiseScoreNames;

	}

	private String getAttributeDisplayName(String scoreName, ResourceBundle bundle) {
		List<PediCTRptSymptomGraphsMetadata> rules = symptomMetadataDao.findByScoreNameInBusinessRule(scoreName);

		if (rules == null || rules.isEmpty())
			return null;

		PediCTRptSymptomGraphsMetadata exactMatchingRule = null;
		Integer exactMatchingRulesCount = 0;
		if (rules.size() > 1) {
			for (PediCTRptSymptomGraphsMetadata r : rules) {
				String[] items = r.getBusinessRule().split(";");
				for (String s : items) {
					if (s.compareTo(scoreName) == 0) {
						exactMatchingRule = r;
						exactMatchingRulesCount++;
					}
				}
			}
			if (exactMatchingRulesCount > 1) {
				logger.debug("Multiple rules found for the same score name: " + scoreName);
				throw new InconsistentDataException();
			} else
				return exactMatchingRule.getDisplayName();
		}
		return rules.get(0).getDisplayName();
	}

	private Answer getAnswerForQuestion(QuestionnaireInstance q, Question question) {
		Answer answer = questInstanceService.getLatestAnswerforQuestion(q, question);
		if (answer != null)
			return answer;
		else {
			if (q.getQuestionnaire().getHl7Entity().getCode().contains("8-12")
					|| q.getQuestionnaire().getHl7Entity().getCode().contains("13plus")) {
				List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(q.getId());
				if (pediScores.size() == 1 && pediScores.get(0) != null) {
					PediScore pScore = pediScores.get(0);
					Score counterPartScore = pScore.getCounterPartScore();
					if (counterPartScore != null) {
						// check if question was answered in the counter part questionnaire
						answer = questInstanceService.getLatestAnswerforQuestion(counterPartScore.getQuestInstance(),
								question);
						return answer;
					}
				}
			}
			return null;
		}

	}

	private ResearchSubject getActiveCaregiverForPatient(ResearchSubject researchSubject) {
		ResearchSubject activeRPCaregiver = null;
		Set<Caregiver> caregiverSet = null;
		List<Patient> patientList = patientDao.findByPersonIdStudyId(researchSubject.getPerson().getId(),
				researchSubject.getStudySite().getStudy().getId());
		if (patientList != null && patientList.size() > 0) {
			Patient dbPatient = patientList.get(0);
			caregiverSet = dbPatient.getCaregivers();
			for (Caregiver caregiver : caregiverSet) {
				List<ResearchSubject> cgRSList = researchSubjectDao.findByPersonIdStudyId(caregiver.getPerson().getId(),
						researchSubject.getStudySite().getStudy().getId());
				if (cgRSList.size() > 0) {
					if (cgRSList.get(0).getPerson().getUser() != null && cgRSList.get(0).getParticipantStudyStatus()
							.getStatus().equals(ParticipantStudyStatusMaster.ParticipantStudyStatus.ACTIVE.getName())) {
						activeRPCaregiver = cgRSList.get(0);
					}
					break;
				}
			}
		}
		return activeRPCaregiver;
	}

	ResearchSubject determineCounterPartRS(ResearchSubject s) {

		logger.debug("determine counter part for the RS");
		ResearchSubject counterPartRs = null;

		if (s.getType().compareTo(ResearchSubjectType.CAREGIVER) == 0) {
			counterPartRs = getPatientForCaregiver(s);
		} else if (s.getType().compareTo(ResearchSubjectType.PATIENT) == 0) {
			counterPartRs = getActiveCaregiverForPatient(s);
		}

		return counterPartRs;
	}

	private void populatePediSummarySection(ReportRecord reportData, ResearchSubject rs, String languageCode) {
		logger.info("In populatePediSummarySection method");

		// List<PediCTReports> oldReports = pediCTReportsDao.findByResearchSubject(rs);
		Set<String> highDistressOthers = new HashSet<String>();
		List<String> othSymptomsForHighDistress = new ArrayList<String>();

		Score previousSurveyScore = null;

		ResourceBundle bundle = null;
		/*
		 * if(languageCode == 2) bundle = ResourceBundle.getBundle("messages", new
		 * Locale("es")); else bundle = ResourceBundle.getBundle("messages", new
		 * Locale("en"));
		 */
		logger.debug("Getting bundle for language Code : " + languageCode);
		bundle = ResourceBundle.getBundle("messages", new Locale(languageCode));
		if (bundle == null) {
			logger.debug("Bundle not found for language code : " + languageCode);
			logger.info("Loading English bundle");
			bundle = ResourceBundle.getBundle("messages", new Locale("en"));
		}

		// Last element should be current score
		// Second last element will be the score of previous survey/administration
		if (reportData.getScoresInReport().size() > 1) {
			previousSurveyScore = reportData.getScoresInReport().get(reportData.getScoresInReport().size() - 2);
		}

		imageBasePath = messageSource.getMessage("report.i18n.image.base.path", null, null);
		reportData.setFooterImagePage1Path(
				/* footnoteImagePath */imageBasePath + bundle.getString("report.i18n.footer.image.page1.name"));
		// reportData.setFooterImagePage2Path(/*footnoteImagePath*/imageBasePath+bundle.getString("report.i18n.footer.image.page2.name"));
		reportData.setBaseImagePath(imageBasePath);

		String beginFieldFontTag = "<font color=\"#375CBA\">";
		String endFieldFontTag = "</font>";
		String beginHeadingFontTag = "<font size=\"3\" isBold=\"true\" color=\"black\"><b>";
		String endHeadingFontTag = "</b></font>";
		String sectionBreak = "<br/><br/>";
		String subSectionBreak = "<br/>";

		// REPORT I18N PROPERTIES LOADED HERE
		String otherChildSymptomsProp = bundle.getString("report.dynamic.i18n.other.child.symptoms");
		String inThePastMnthProp = bundle.getString("report.dynamic.i18n.in.past.month");
		String whenOTHNotAnsweredChild = bundle.getString("report.dynamic.i18n.when.oth.not.answered.child");
		String whenOTHNotAnsweredParent = bundle.getString("report.dynamic.i18n.when.oth.not.answered.parent");

		List<SymptomData> otherChildSymptoms = new ArrayList<SymptomData>();
		List<SymptomData> otherParentReportedSymptoms = new ArrayList<SymptomData>();

		StringBuffer otherSymtoms = new StringBuffer();
		StringBuffer summaryReport = new StringBuffer();
		Person rsPerson = rs.getPerson();

		Map<String, Map<String, ScoresDetails>> currentReportScoresMap = createScoreDetailsMapForSymptom(
				reportData.getScoresInReport().get(reportData.getScoresInReport().size() - 1).getScorevalues());

		// Other Symptom Section
		otherSymtoms.append(beginHeadingFontTag + otherChildSymptomsProp + " " + endHeadingFontTag);
		otherSymtoms.append(subSectionBreak);

		Float averageScore = Float.valueOf(-1);
		StringBuffer otherSymptomsChildText = new StringBuffer();
		String textEntered = "";
		Question q = new Question();
		List<String> newOtherSymptoms = new ArrayList<String>();
		List<String> othSymptomsForNewSymptoms = new ArrayList<String>();

//		otherChildSymptoms = this.populateOtherSysmptomsFromChildsLatestInstance(reportData,othSymptomsForHighDistress,newOtherSymptoms,currentReportScoresMap);
		otherParentReportedSymptoms = this.populateOtherSymptomsFromParentsLatestInstance(reportData,
				othSymptomsForHighDistress, newOtherSymptoms, currentReportScoresMap, languageCode);

		// REPORT I18N PROPERTIES LOADED HERE
		String alsoReportedProp = bundle.getString("report.dynamic.i18n.also.reported");
		String averageScoreProp = bundle.getString("report.dynamic.i18n.average.score");
		String notReportedProp = bundle.getString("report.dynamic.i18n.not.reported");

		logger.debug("Other child symptoms reported by child are:" + otherChildSymptoms.size());
		// Other symptoms reported by child
		/*
		 * if(otherChildSymptoms.size()>0) { Boolean firstElement = Boolean.TRUE;
		 * otherSymptomsChildText.append(beginFieldFontTag+reportData.
		 * getPatientFirstName()+endFieldFontTag+" "+alsoReportedProp+beginFieldFontTag)
		 * ; for(SymptomData s:otherChildSymptoms) { if(firstElement) {
		 * otherSymptomsChildText.append(" "); firstElement=Boolean.FALSE; } else
		 * otherSymptomsChildText.append(", ");
		 * otherSymptomsChildText.append(s.symptomName+" ("+averageScoreProp+" ");
		 * if(s.score>0){ otherSymptomsChildText.append(s.score+")"); } else
		 * otherSymptomsChildText.append(notReportedProp); }
		 * otherSymptomsChildText.append(endFieldFontTag+"."+subSectionBreak); }
		 */
		// else
		// {
		// When none of oth question answered by child.
		/*
		 * if(!reportData.getLatestQuestInstance().getQuestionnaire().getHl7Entity().
		 * getCode().contains("PQ2-4") &&
		 * !reportData.getLatestQuestInstance().getQuestionnaire().getHl7Entity().
		 * getCode().contains("PQ5-6")) {
		 * otherSymptomsChildText.append(whenOTHNotAnsweredChild+"."+subSectionBreak); }
		 */
		// }

		// Other symptoms reported by Parent
		StringBuffer otherSymptomsParentText = new StringBuffer();

		// REPORT I18N PROPERTIES
		String sParent = bundle.getString("report.dynamic.i18n.s.parent");
		String had = bundle.getString("report.dynamic.i18n.had");
		String newHad = bundle.getString("report.dynamic.i18n.had.new.spanish");

		if (otherParentReportedSymptoms.size() > 0) {
			Boolean firstElement = Boolean.TRUE;
			if (languageCode.equals("es")) {
				otherSymptomsParentText.append(sParent + " " + beginFieldFontTag + reportData.getPatientFirstName()
						+ endFieldFontTag + " " + alsoReportedProp + " " + beginFieldFontTag
						+ reportData.getPatientFirstName() + endFieldFontTag + " " + newHad + " " + beginFieldFontTag);
			} else if (languageCode.equals("en")) {
				otherSymptomsParentText.append(beginFieldFontTag + reportData.getPatientFirstName() + sParent + " "
						+ endFieldFontTag + alsoReportedProp + " " +
						/*
						 * beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+" "+
						 * newHad +
						 */ " " + beginFieldFontTag);
			}
			for (SymptomData s : otherParentReportedSymptoms) {
				if (firstElement) {
					otherSymptomsParentText.append(" ");
					// otherSymptomsParentText.append(s.symptomName + " (" + averageScoreProp + "
					// ");
					firstElement = Boolean.FALSE;
				} else

					otherSymptomsParentText.append(", ");

				otherSymptomsParentText.append(s.symptomName + " (" + averageScoreProp + " ");
				if (s.score > 0)
					// if the average is valid
					otherSymptomsParentText.append(s.score + ")");
				else
					otherSymptomsParentText.append(notReportedProp);
			}
			// do not end the sentence here because we need to append bleeding and seizures
			// after this.
		}

		else {
			otherSymptomsParentText.append(" (" + notReportedProp);
		}

		String bleedingDistressScale = "";
		String seizuresDistressScale = "";

		// Parental Distress From Child Symptoms
		String bleedingDistressScaleParent = "";
		String seizuresDistressScaleParent = "";
		String anorexDistressScaleParent = "";
		String sleepDistressScaleParent = "";
		String weightcDistressScaleParent = "";

		QuestionnaireInstance parentsInstance = null;
		/*
		 * if(reportData.getLatestQuestInstance().getResearchSubject().getType() ==
		 * ResearchSubjectType.PATIENT) {
		 * logger.info("Latest answered survey in report data was by patient");
		 * logger.info("Get parents latest answered survey"); parentsInstance =
		 * getLatestOtherPartyInstance(reportData.getLatestQuestInstance()); } else
		 */
		parentsInstance = reportData.getLatestQuestInstance();

		// Bleeding Distress to the parent
		ScoresDetails sd = null;
		if (currentReportScoresMap.containsKey("MSAS_pf")) {
			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_bleed_both_p");
			if (sd != null && sd.getValue().intValue() >= 0) {
				bleedingDistressScaleParent = this.getTextForAnswerValue(sd.getValue(), bundle);
			}

			// Bleeding Distress to the child as per parent form

			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_bleed_both");
			Question q1 = questionService.getQuestionByCodeForSection("MSAS_bleed_both", "MSAS_pf",
					parentsInstance.getQuestionnaire().getMainContainer().getId());
			if (q1 != null) {
				Answer answer = getAnswerForQuestion(reportData.getLatestQuestInstance(), q1);
				if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED) {
					if (sd != null && sd.getValue().intValue() >= 0) {
						if (sd.getValue().intValue() >= 50) {
							highDistressOthers.add("bleeding");
						}
						bleedingDistressScale = this.getTextForAnswerValue(sd.getValue(), bundle);
					}
				}
			}

			// Seizures Distress to the parent
			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_seiz_both_p");
			if (sd != null && sd.getValue() >= 0) {
				seizuresDistressScaleParent = this.getTextForAnswerValue(sd.getValue(), bundle);
			}

			// Seizures Distress to the child as per parent form

			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_seiz_both");
			Question q2 = questionService.getQuestionByCodeForSection("MSAS_seiz_both", "MSAS_pf",
					parentsInstance.getQuestionnaire().getMainContainer().getId());
			if (q2 != null) {
				Answer answer = getAnswerForQuestion(reportData.getLatestQuestInstance(), q2);
				if (answer != null && answer.getAnswerStatus() != AnswerStatus.SKIPPED) {
					if (sd != null && sd.getValue().intValue() > 0) {
						if (sd.getValue().intValue() >= 50) {	
							highDistressOthers.add("seizures");
						}
						seizuresDistressScale = this.getTextForAnswerValue(sd.getValue(), bundle);
					}
				}
			}
			// Anorex Distress to the parent
			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_anorex_both_p");
			if (sd != null && sd.getValue().intValue() >= 0) {
				anorexDistressScaleParent = this.getTextForAnswerValue(sd.getValue(), bundle);
			}

			// Sleep Distress to the parent
			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_sleep_both_p");
			if (sd != null && sd.getValue().intValue() >= 0) {
				sleepDistressScaleParent = this.getTextForAnswerValue(sd.getValue(), bundle);
			}
			// weightc Distress to the parent
			sd = currentReportScoresMap.get("MSAS_pf").get("MSAS_weightc_both_p");
			if (sd != null && sd.getValue().intValue() >= 0) {
				weightcDistressScaleParent = this.getTextForAnswerValue(sd.getValue(), bundle);
			}
		}
		// REPORT I18n PROPERTIES
		String alsoReportedThat = /*
									 * beginFieldFontTag + reportData.getPatientFirstName() + " " + endFieldFontTag
									 * +
									 */bundle.getString("report.dynamic.i18n.also.reported.that");
		String bleeding = bundle.getString("report.dynamic.i18n.bleeding");
		String seizures = bundle.getString("report.dynamic.i18n.seizures");
		String distressedByBleeding = bundle.getString("report.dynamic.i18n.distressed.by.bleeding");
		String distressedBySeizures = bundle.getString("report.dynamic.i18n.distressed.by.seizures");
		String reportThat = bundle.getString("report.dynamic.i18n.reported.that");
		String was = bundle.getString("report.dynamic.i18n.was");
		String othEndText = bundle.getString("report.dynamic.i18n.oth.end.statement");
		String weightc = bundle.getString("report.dynamic.i18n.weightc");
		// String discomfortFor =
		// bundle.getString("report.dynamic.i18n.discomfort.for");

		String alsoreportedThat = bundle.getString("report.dynamic.i18n.other.child.symptom.also.reported.that");

		if (!bleedingDistressScale.isEmpty()) {
			if (otherSymptomsParentText.length() == 0) {
				if (languageCode.equals("es")) {
					otherSymptomsParentText.append(
							/* beginFieldFontTag+reportData.getPatientFirstName()+ */sParent + " " + endFieldFontTag
									+ alsoreportedThat + " " + beginFieldFontTag + reportData.getPatientFirstName()
									+ endFieldFontTag + " " + had + " " + beginFieldFontTag + " ");
				} else if (languageCode.equals("en")) {
					otherSymptomsParentText.append(
							beginFieldFontTag + reportData.getPatientFirstName() + sParent + " " + endFieldFontTag
									+ alsoreportedThat + " " + beginFieldFontTag + reportData.getPatientFirstName()
									+ endFieldFontTag + " " + had + " " + beginFieldFontTag + " ");
				}
			} /*
				 * else { otherSymptomsParentText.append(", "); }
				 */
		}

//		if(!seizuresDistressScale.isEmpty())
//		{
//			if (otherSymptomsParentText.length()==0)
//			{
//				if(languageCode.equals("es"))
//				{
//					otherSymptomsParentText.append(/*beginFieldFontTag+reportData.getPatientFirstName()+*/sParent+" "+endFieldFontTag+alsoreportedThat+" " +
//					beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+" "+had+" "+beginFieldFontTag+" "+seizures);
//				}
//				else if(languageCode.equals("en"))
//				{
//					otherSymptomsParentText.append(beginFieldFontTag+reportData.getPatientFirstName()+sParent+" "+endFieldFontTag+alsoreportedThat+" " +
//					beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+" "+had+" "+beginFieldFontTag+" "+seizures);
//				}
//					
//			}else
//			{
//				otherSymptomsParentText.append(", "+seizures);
//			}
//		}

		// end the parent text sentence here.
		if (otherSymptomsParentText.length() > 0) {
			otherSymptomsParentText.append(endFieldFontTag + "." + subSectionBreak);
		} else {
			// Set this when none of the oth symptom questions are answered.
			// otherSymptomsParentText.append(whenOTHNotAnsweredParent+"."+subSectionBreak);
		}

		StringBuffer otherSymptomsBleedingText = new StringBuffer();
		StringBuffer otherSymptomsSeizuresText = new StringBuffer();
		if (!bleedingDistressScale.isEmpty()) {
			if (languageCode.equals("es")) {
				otherSymptomsBleedingText.append(/* beginFieldFontTag+reportData.getPatientFirstName()+ */sParent + " "
						+ " " + beginFieldFontTag + reportData.getPatientFirstName() + endFieldFontTag + " "
						+ reportThat + " " + "el grado de molestia por" + " " + distressedByBleeding + " "
						+ beginFieldFontTag + reportData.getPatientFirstName() + endFieldFontTag + " " + "es: " + " "
						+ beginFieldFontTag + bleedingDistressScale + endFieldFontTag + subSectionBreak);
			} else if (languageCode.equals("en")) {
				otherSymptomsBleedingText.append(beginFieldFontTag + reportData.getPatientFirstName() + sParent + " "
						+ endFieldFontTag + " " + reportThat + " " + beginFieldFontTag
						+ reportData.getPatientFirstName() + endFieldFontTag + " " + was + " " + beginFieldFontTag
						+ bleedingDistressScale + endFieldFontTag + " " + distressedByBleeding + subSectionBreak);
			}
		}
//		if(!seizuresDistressScale.isEmpty())
//		{
//			if(languageCode.equals("es"))
//			{
//				otherSymptomsSeizuresText.append(/*beginFieldFontTag+reportData.getPatientFirstName()+*/sParent+" "+endFieldFontTag+" "+reportThat+" "+
//					 beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+" "+was+" "+beginFieldFontTag+
//					 seizuresDistressScale+endFieldFontTag+ " "+distressedBySeizures+subSectionBreak);
//			}
//			else if(languageCode.equals("en"))
//			{
//				otherSymptomsSeizuresText.append(beginFieldFontTag+reportData.getPatientFirstName()+sParent+" "+endFieldFontTag+" "+reportThat+" "+
//						 beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+" "+was+" "+beginFieldFontTag+
//						 seizuresDistressScale+endFieldFontTag+ " "+distressedBySeizures+subSectionBreak);
//			}
//		}
//		
		Boolean noTextUnderOtherSymptoms = Boolean.TRUE;
		if (otherSymptomsChildText.length() > 0) {
			noTextUnderOtherSymptoms = Boolean.FALSE;
			otherSymtoms.append(otherSymptomsChildText);
		}

		if (otherSymptomsParentText.length() > 0) {
			noTextUnderOtherSymptoms = Boolean.FALSE;
			otherSymtoms.append(otherSymptomsParentText);
		}

		if (otherSymptomsBleedingText.length() > 0) {
			noTextUnderOtherSymptoms = Boolean.FALSE;
			otherSymtoms.append(otherSymptomsBleedingText);
		}
		if (otherSymptomsSeizuresText.length() > 0) {
			noTextUnderOtherSymptoms = Boolean.FALSE;
			otherSymtoms.append(otherSymptomsSeizuresText);
		}

		// Add final to otherSymptoms string which should displayed always.
		// otherSymtoms.append(othEndText + sectionBreak);
		otherSymtoms.append(sectionBreak);

		// REPORT I18n PROPERTIES
		String didNotHaveAny = bundle.getString("report.dynamic.i18n.did.not.have.any");
		String andOrOr = bundle.getString("report.dynamic.i18n.and.or.or");
		String didNotReport = bundle.getString("report.dynamic.i18n.did.not.report");
		String none = bundle.getString("report.dynamic.i18n.none");
		String poorAppetite = bundle.getString("report.dynamic.i18n.poor.appetite");
		String sleepingProblems = bundle.getString("report.dynamic.i18n.sleeping.problems");
		String parentalDistress = bundle.getString("report.dynamic.i18n.parental.distress");
		String notAssessed = bundle.getString("report.dynamic.i18n.not.assessed");
		String parentDistressScaleZero = bundle.getString("report.dynamic.i18n.parent.distress.when.scale.zero");
		String parentDistressFor = bundle.getString("report.dynamic.i18n.parent.distress.for");
		String parentDistressAndFor = bundle.getString("report.dynamic.i18n.parent.distress.andfor");
		String parentDistressInSymptomWithoutNotAtAllCase = bundle
				.getString("report.dynamic.i18n.parent.distress.when.some.skipped.or.answered.not");
		String ParentDistressNote = bundle.getString("report.dynamic.i18n.parent.distress.note");
		String weightChanges = bundle.getString("report.dynamic.i18n.weightchanges");
		// Symptom that are not present
		/*
		 * if(reportData.getSymptomsNotPresent().size()>0) {
		 * noTextUnderOtherSymptoms=Boolean.FALSE;
		 * 
		 * //For PQ2-4 and PQ5-6, PQ13p
		 * if(reportData.getLatestQuestInstance().getQuestionnaire().getHl7Entity().
		 * getCode().contains("PQ2-4") ||
		 * reportData.getLatestQuestInstance().getQuestionnaire().getHl7Entity().getCode
		 * ().contains("PQ5-6")
		 * ||reportData.getLatestQuestInstance().getQuestionnaire().getHl7Entity().
		 * getCode().contains("PQ13plusp")) {
		 * otherSymtoms.append(beginFieldFontTag+reportData.getPatientFirstName()+
		 * sParent+endFieldFontTag+" "+reportThat+" "+
		 * beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+
		 * " "+didNotHaveAny+" "+beginFieldFontTag); } //For 13 Plus child else
		 * if(reportData.getLatestQuestInstance().getQuestionnaire().getHl7Entity().
		 * getCode().contains("PQ13plus")) {
		 * otherSymtoms.append(beginFieldFontTag+reportData.getPatientFirstName()+
		 * endFieldFontTag+ " "+didNotReport+" "+beginFieldFontTag); } //For PQ7 or
		 * PQ8-12 or PQ8-12p else {
		 * otherSymtoms.append(beginFieldFontTag+reportData.getPatientFirstName()+
		 * endFieldFontTag+" "+andOrOr+" "+
		 * beginFieldFontTag+reportData.getPatientFirstName()+sParent+
		 * endFieldFontTag+" "+reportThat+" "+
		 * beginFieldFontTag+reportData.getPatientFirstName()+endFieldFontTag+
		 * " "+didNotReport+" "+beginFieldFontTag); } int i = 0; for (String
		 * s:reportData.getSymptomsNotPresent()) { if(i>0) otherSymtoms.append(", ");
		 * else i++; otherSymtoms.append(s.toLowerCase().trim()); } if(i>0)
		 * otherSymtoms.append(endFieldFontTag+inThePastMnthProp+" "+sectionBreak); }
		 * if(noTextUnderOtherSymptoms) otherSymtoms.append(none+sectionBreak);
		 */

		StringBuffer parentDistress = new StringBuffer();
		// Map to store the distress values
		Map<String, String> parentalDistressSimpleMap = new HashMap<String, String>();

		if (!bleedingDistressScaleParent.isEmpty()) {
			parentalDistressSimpleMap.put(bleeding, bleedingDistressScaleParent);
		}

		if (!seizuresDistressScaleParent.isEmpty()) {
			parentalDistressSimpleMap.put(seizures, seizuresDistressScaleParent);
		}

		if (!anorexDistressScaleParent.isEmpty()) {
			parentalDistressSimpleMap.put(poorAppetite, anorexDistressScaleParent);
		}

		if (!sleepDistressScaleParent.isEmpty()) {
			parentalDistressSimpleMap.put(sleepingProblems, sleepDistressScaleParent);
		}

		if (!weightcDistressScaleParent.isEmpty()) {
			parentalDistressSimpleMap.put(weightChanges, weightcDistressScaleParent);
		}

		Map<String, String> symptomWithNotAtAll = new HashMap<String, String>();
		Map<String, String> symptomWithoutNotAtAll = new HashMap<String, String>();

		if (parentalDistressSimpleMap.size() > 0) {
			for (Map.Entry<String, String> entry : parentalDistressSimpleMap.entrySet()) {
				if (entry.getValue().equals(bundle.getString("MSAS_SUB_QUESTION_0")))
					symptomWithNotAtAll.put(entry.getKey(), entry.getValue());
				else {
					if (entry.getValue().equals("Muy")) {
						entry.setValue("Mucho");
					}
					symptomWithoutNotAtAll.put(entry.getKey(), entry.getValue());
				}
			}
		}

		if (symptomWithoutNotAtAll.size() > 0) {
			parentDistress.append(subSectionBreak + alsoReportedThat);
			int cnt = 0;
			int totalSize = symptomWithoutNotAtAll.size();
			// Now iterate over each value and generate parental distress sentences

			for (Map.Entry<String, String> entry : symptomWithoutNotAtAll.entrySet()) {

				if (cnt == 0) {
					parentDistress.append(" ");
				} else if (cnt == totalSize - 1) {
					parentDistress.append("; " + parentDistressAndFor + " ");
				} else {
					parentDistress.append("; " + parentDistressFor + " ");
				}

				/*
				 * else if(cnt == 1 || cnt == 2){
				 * parentDistress.append(", "+parentDistressFor+" "); } else if(cnt==3){
				 * parentDistress.append(", "+parentDistressAndFor+" "); }
				 */
				parentDistress.append(beginFieldFontTag + "<i>" + entry.getKey().toLowerCase() + "</i>" + ": "
						+ entry.getValue().toLowerCase() + endFieldFontTag);
				cnt++;
			}
			parentDistress.append(".");
		}

		otherSymtoms.append(beginHeadingFontTag + parentalDistress + " " + endHeadingFontTag);
		/*
		 * if(parentDistress.length()>0) { otherSymtoms.append(subSectionBreak);
		 * 
		 * if(allSymptomScaleZero(bleedingDistressScaleParent,
		 * seizuresDistressScaleParent,anorexDistressScaleParent,
		 * sleepDistressScaleParent,bundle))
		 * otherSymtoms.append(parentDistressScaleZero); else
		 * otherSymtoms.append(parentDistress); } else {
		 * //otherSymtoms.append(subSectionBreak+"None");
		 * otherSymtoms.append(subSectionBreak+notAssessed); }
		 */
		if (symptomWithoutNotAtAll.size() >= 1) {
			// 1
			otherSymtoms.append(parentDistress);
			otherSymtoms.append(subSectionBreak);
			otherSymtoms.append(parentDistressInSymptomWithoutNotAtAllCase);
		} else if (symptomWithNotAtAll.size() == 4) {
			// 2
			otherSymtoms.append(subSectionBreak + parentDistressScaleZero);
		} else {
			// 3
			otherSymtoms.append(
					subSectionBreak + notAssessed + subSectionBreak + parentDistressInSymptomWithoutNotAtAllCase);
		}

		otherSymtoms.append(sectionBreak);

		// Add summary report to the report data
		reportData.setOtherSymptoms(otherSymtoms.toString());

		// PediQUEST Summary Highlights
		// summaryReport.append(beginHeadingFontTag+"PediQUEST Summary Highlights
		// "+endHeadingFontTag);
		// summaryReport.append(subSectionBreak);

		// numerical scale for summary section
		Float NumericalScaleSummaryReport = getPedQLScore(currentReportScoresMap, "NS");
		logger.debug("NumericalScaleSummaryReport : " + NumericalScaleSummaryReport);

		// comment code because now nccpcr not used in the graph
		// Todays total
		// Float totalQOLThisReport = getPedQLScore(currentReportScoresMap,
		// "nccpcr_tot");

		// REPORT I18N properties
		logger.debug("Message in " + " Spanish " + ":" + bundle.getString("report.i18n.Symptom"));
		String inSummary = bundle.getString("report.dynamic.i18n.in.summary");
		String qolScoreIs = bundle.getString("report.dynamic.i18n.s.qol.score.is");
		String painNumericalScoreIs = bundle.getString("report.dynamic.i18n.s.pain.numerical.score.is");
		String painNCCPC_RScoreIs = bundle.getString("report.dynamic.i18n.s.pain.NCCPC_R.score.is");
		String Points = bundle.getString("report.dynamic.i18n.points");
		String Scores = bundle.getString("report.dynamic.i18n.scores");
		String referenceRange = bundle.getString("report.dynamic.i18n.reference.range");
		String noQolForRecentSurvey = bundle.getString("report.dynamic.i18n.no.qol.for.recent.survey");
		String noModerateOrDistress = bundle.getString("report.dynamic.i18n.no.moderate.distress");
		String cmpToLastReport = bundle.getString("report.dynamic.i18n.compare.to.last.report");
		String curQolScoreHas = bundle.getString("report.dynamic.i18n.current.qol.score.has");
		String curPainNumericalScoreHas = bundle.getString("report.dynamic.i18n.current.painnumerical.score.has");
		String points = bundle.getString("report.dynamic.i18n.points");
		String notChanges = bundle.getString("report.dynamic.i18n.not.changes");
		String decreasedBy = bundle.getString("report.dynamic.i18n.decreased.by");
		String increasedBy = bundle.getString("report.dynamic.i18n.increased.by");
		String painReferenceRange = bundle.getString("report.dynamic.i18n.pain.reference.range");
		String NCCP_R_ReferenceRange = bundle.getString("report.dynamic.i18n.NCCPC_R.reference.range");
		String by = bundle.getString("report.dynamic.i18n.by");
		String and = bundle.getString("report.dynamic.i18n.and");

		// String summaryPoints =
		// bundle.getString("report.dynamic.i18n.summary.points.dynamic");

		String physical = bundle.getString("report.dynamic.i18n.physical");
		String emotional = bundle.getString("report.dynamic.i18n.emotional");
		String social = bundle.getString("report.dynamic.i18n.social");
		String school = bundle.getString("report.dynamic.i18n.school");
		String decreaseInQol = bundle.getString("report.dynamic.i18n.decrease.in.qol");
		String functioning = bundle.getString("report.dynamic.i18n.functioning");
		String pleaseNoteThat = bundle.getString("report.dynamic.i18n.please.note.that");
		String surveyAndministered = bundle.getString("report.dynamic.i18n.survey.administrated");
		String hasNewSymptoms = bundle.getString("report.dynamic.i18n.new.symptoms");
		String hasNewSymptomsFirstTime = bundle.getString("report.dynamic.i18n.new.symptoms.for.first.time");
		String daysBeforeCurrSurvey = bundle.getString("report.dynamic.i18n.current.survey");
		String summaryReportEs = bundle.getString("report.dynamic.i18n.es");
		String mostBothersomeProblemText = bundle.getString("report.dynamic.i18n.mostBothersomeProblem");
		String intro1 = bundle.getString("report.i18n.pedi.summary.intro.sentence1");
		String intro2 = bundle.getString("report.i18n.pedi.summary.intro.sentence2");
		// summaryReport.append(inSummary + " "+beginFieldFontTag +
		// rsPerson.getFirstName() + endFieldFontTag + " " + "are:" +sectionBreak);
		// for Diff_days_DD

		// old code If NRS and NCCPC-R reported in most recent survey

//		String difficultDayText = bundle.getString("report.dynamic.i18n.difficultday.text");
//		String difficultdaypastweek = bundle.getString("report.dynamic.i18n.difficultdaypastweek.text");
//		String nodifficultdayPastWeek = bundle.getString("report.dynamic.i18n.nodifficultday.text");
//		String typicalDay = bundle.getString("report.dynamic.i18n.typicalday.text");
//		String parentSectionCodeDiffDays = null;
//		parentSectionCodeDiffDays = "Diff_days";
//		String enteredTextDifficultday = null;
//		logger.debug("parentSectionCodeDiffDays : " + parentSectionCodeDiffDays);
//
//		Question questionDiffDay = null;
//		Float averageScoresDiffDays = null;
//
//		averageScoresDiffDays = Float.valueOf(-1);
//		// check if the lead question was answered
//		questionDiffDay = questionService.getQuestionByCodeForSection("DD", parentSectionCodeDiffDays,
//				parentsInstance.getQuestionnaire().getMainContainer().getId());
//		if (questionDiffDay != null) {
//			Answer answer = getAnswerForQuestion(parentsInstance, questionDiffDay);
//			if (answer != null)
//
//			{
//				//enteredTextDifficultday = answer.getAnswerData().toLowerCase().trim();
//				Set<AnswerOption> answerOption = answer.getOptionChoosen();
//
//				for (AnswerOption item : answerOption) {
//					List<AnswerOptionContent> answerOptionContent = item.getAnswerOptionContents();
//					// for (int i = 0; i < answerOptionContent.size(); i++) {
//					AnswerOptionContent content = answerOptionContent.get(0);
//					enteredTextDifficultday = content.getAnswerText();
//				    
//					if (enteredTextDifficultday.equals("Yes")) {
//
//						summaryReport.append(
//								difficultDayText +" "+ beginFieldFontTag/* +"[" */ + rsPerson.getFirstName() /* +"]" */
//										+ endFieldFontTag + " " + difficultdaypastweek + " "
//										+ beginFieldFontTag /* + enteredTextDifficultday */  + endFieldFontTag
//										+ sectionBreak);
//					} else {
//						if (languageCode.equals("en")) {
//						summaryReport.append(beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
//								+ nodifficultdayPastWeek + typicalDay + " " + sectionBreak);
//						}
//						else
//						{
//							summaryReport.append(nodifficultdayPastWeek +beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
//									+  typicalDay + " " + subSectionBreak);
//						}
//					}
//
//				}
//			}
//
//		}

		// new code If NRS reported in most recent survey AND Diff_days_DDS not equal to
		// 0
		// introduction sentence
		summaryReport.append(intro1 + " " + beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + intro2
				+ sectionBreak);

		// for pain numerical summary section
		int flag1 = 0;
		int flag2 = 0;
		int flag3 = 0;

		// if NumericalScaleSummaryReport is not equal to zero means If NRS reported in
		// most recent survey
		if (NumericalScaleSummaryReport != null && !(NumericalScaleSummaryReport < 0)) {
			logger.debug("If NRS reported in most recent survey : ");
			String difficultDayText = bundle.getString("report.dynamic.i18n.difficultday.text");
			String difficultdaypastweek = bundle.getString("report.dynamic.i18n.difficultdaypastweek.text");
			String nodifficultdayPastWeek = bundle.getString("report.dynamic.i18n.nodifficultday.text");
			String typicalDay = bundle.getString("report.dynamic.i18n.typicalday.text");
			String parentSectionCodeDiffDays = null;
			parentSectionCodeDiffDays = "Diff_days";
			String enteredTextDifficultday = null;
			logger.debug("parentSectionCodeDiffDays : " + parentSectionCodeDiffDays);

			Question questionDiffDay = null;
			Float averageScoresDiffDays = null;

			averageScoresDiffDays = Float.valueOf(-1);
			// check if the lead question was answered
			questionDiffDay = questionService.getQuestionByCodeForSection("DDS", parentSectionCodeDiffDays,
					parentsInstance.getQuestionnaire().getMainContainer().getId());

			logger.debug("questionDiffDay : " + questionDiffDay);

			if (questionDiffDay != null) {
				Answer answer = getAnswerForQuestion(parentsInstance, questionDiffDay);

				logger.debug("answer : " + answer);

				if (answer != null) {
//				if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty()) {
					Set<AnswerOption> answerOption = answer.getOptionChoosen();
					for (AnswerOption item : answerOption) {
						List<AnswerOptionContent> answerOptionContent = item.getAnswerOptionContents();
						AnswerOptionContent content = answerOptionContent.get(0);
						enteredTextDifficultday = content.getAnswerText();

						logger.debug("enteredTextDifficultday : " + enteredTextDifficultday);

						// if Diff_days_DDS not equal to 0
//						if ((!enteredTextDifficultday.equals("0 difficult days")) && enteredTextDifficultday!=null && enteredTextDifficultday.equals("") && enteredTextDifficultday.isEmpty()) {
						if ((enteredTextDifficultday != null)
								&& (!enteredTextDifficultday.equals("0 difficult days"))) {
							// flag2 = 0;
							logger.debug("if Diff_days_DDS not equal to 0 : " + enteredTextDifficultday);
							// if (enteredTextDifficultday.equalsIgnoreCase("Yes")) {
							if (languageCode.equals("en")) {
								logger.debug("under English Diff_days_DDS not equal to 0 : " + enteredTextDifficultday);
								summaryReport.append(difficultDayText + " " + beginFieldFontTag
										+ rsPerson.getFirstName() + endFieldFontTag + " " + difficultdaypastweek + " "
//										+ beginFieldFontTag + enteredTextDifficultday + endFieldFontTag + sectionBreak);
										+ sectionBreak);
								// add Numerical Score:
//								summaryReport.append(painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
								summaryReport
										.append(summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
												+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
								// add reference range
								summaryReport.append(painReferenceRange + subSectionBreak);
								summaryReport.append(subSectionBreak);
							} else {
								logger.debug("under Spanish Diff_days_DDS not equal to 0 : " + enteredTextDifficultday);
								summaryReport.append(difficultDayText + " " + beginFieldFontTag
										+ rsPerson.getFirstName() + endFieldFontTag + " " + difficultdaypastweek + " "
//										+ beginFieldFontTag + enteredTextDifficultday + endFieldFontTag + sectionBreak);
										+ sectionBreak);
								// add Numerical Score:
//								summaryReport.append(painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
								summaryReport
										.append(summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
												+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
								// add reference range
								summaryReport.append(painReferenceRange + subSectionBreak);
								summaryReport.append(subSectionBreak);
							}
							// } else {
//							if (languageCode.equals("en")) {
//								summaryReport.append(beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
//										+ nodifficultdayPastWeek + typicalDay + " " + sectionBreak);
//							} else {
//								summaryReport
//										.append(nodifficultdayPastWeek + beginFieldFontTag + rsPerson.getFirstName()
//												+ endFieldFontTag + " " + typicalDay + " " + subSectionBreak);
//							}
							// }

							// if Diff_days_DDS equal to 0
						} else if (enteredTextDifficultday.equals("0 difficult days")) {
							// flag2 = 0;
							logger.debug("if Diff_days_DDS equal to 0 : " + enteredTextDifficultday);
							if (languageCode.equals("en")) {
								logger.debug("under English Diff_days_DDS equal to 0 : " + enteredTextDifficultday);
								summaryReport.append(beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
										+ nodifficultdayPastWeek + typicalDay + " " + sectionBreak);

								// add Numerical Score:
//								summaryReport.append(painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
								summaryReport
										.append(summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
												+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
								// add reference range
								summaryReport.append(painReferenceRange + subSectionBreak);
								summaryReport.append(subSectionBreak);

//						} else {	
//							logger.debug("below without en enteredTextDifficultday : " + enteredTextDifficultday);
//							summaryReport
//									.append(nodifficultdayPastWeek + beginFieldFontTag + rsPerson.getFirstName()
//											+ endFieldFontTag + " " + typicalDay + " " + subSectionBreak);
//						}

							} else {
								logger.debug("under Spanish Diff_days_DDS equal to 0 : " + enteredTextDifficultday);
								summaryReport.append(beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
										+ nodifficultdayPastWeek + typicalDay + " " + sectionBreak);

								// add Numerical Score:
//								summaryReport.append(painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
								summaryReport
										.append(summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
												+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
								// add reference range
								summaryReport.append(painReferenceRange + subSectionBreak);
								summaryReport.append(subSectionBreak);
							}

						}

						// if does not fill the question or not answered
						else {
							flag2 = 1;
							if (flag2 == 1) {
								logger.debug("Diff days does not answered in diff days..." + enteredTextDifficultday);
								// add Numerical Score:
//							summaryReport.append(painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
								summaryReport
										.append(summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
												+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
								// add reference range
								summaryReport.append(painReferenceRange + subSectionBreak);
								summaryReport.append(subSectionBreak);
							}
						}
					}
				}
				// if diff_days does not fill the question or not answered
				// if (answer != null && answer.getAnswerData() != null &&
				// !answer.getAnswerData().isEmpty()) {
				// else if (answer == null && answer.getAnswerData() == null &&
				// answer.getAnswerData().isEmpty()) {
				else {
					flag2 = 1;
					if (flag2 == 1) {
						logger.debug("Diff days does not answered..." + enteredTextDifficultday);
						// add Numerical Score:
//					summaryReport.append(painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
						summaryReport.append(summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
								+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
						// add reference range
						summaryReport.append(painReferenceRange + subSectionBreak);
						summaryReport.append(subSectionBreak);
					}
				}
			}

//		// for pain numerical summary section
//		int flag1 = 0;
//		// if NumericalScaleSummaryReport is not equal to zero
//		if (NumericalScaleSummaryReport != null && !(NumericalScaleSummaryReport < 0)) {
//			if (languageCode.equals("en")) {
//				summaryReport.append(/*
//										 * inSummary + " " + beginFieldFontTag + rsPerson.getFirstName() +
//										 * endFieldFontTag /*+ "]" /*+ " " +"are:" +sectionBreak+
//										 */

			// painNumericalScoreIs- Numerical score:
			// NumericalScaleSummaryReport---> get Numerical scale value
			// painReferenceRange-->(Reference range: 0-2 (no pain)/ 3-5 (mild) / 6-7
			// (moderate) / 8-10 (severe)).

			// painNumericalScoreIs-Dolor-numrico:
			// NumericalScaleSummaryReport---> get Numerical scale value
			// painReferenceRange---> (Rango de referencia: 0-2 (sin dolor)/ 3-5 (leve) /
			// 6-7 (moderado) / 8-10 (severo)).

//						painNumericalScoreIs + summaryReportEs + " " + beginFieldFontTag + NumericalScaleSummaryReport
//								+ "/10" + endFieldFontTag + " " + "." + subSectionBreak);
//				summaryReport.append(painReferenceRange + subSectionBreak);
//			} else {
//				summaryReport.append(/*
//										 * inSummary + " " + beginFieldFontTag + rsPerson.getFirstName() +
//										 * endFieldFontTag
//										 */
//						/* + "]"+ " " + "son:" +sectionBreak+ */ painNumericalScoreIs + summaryReportEs + " "
//								+ beginFieldFontTag + NumericalScaleSummaryReport + "/10" + endFieldFontTag + " " + "."
//								+ subSectionBreak);
//				summaryReport.append(painReferenceRange + subSectionBreak);
//			}

			// if NumericalScaleSummaryReport is equal to zero means If NRS not reported in
			// most recent survey
		} else {
			flag1 = 1;
			// summaryReport.append(noQolForRecentSurvey + sectionBreak);

			// for NCCPC-R summary section
//		int flag2 = 0;
//		if (totalQOLThisReport != null && !(totalQOLThisReport < 0)) {
//			if (languageCode.equals("en")) {
//				summaryReport.append(/*
//										 * inSummary+" "+beginFieldFontTag+rsPerson.getFirstName()+endFieldFontTag+"]"
//										 * +" "+"are:"+" "+
//										 */painNCCPC_RScoreIs + summaryReportEs + " " + beginFieldFontTag
//						+ totalQOLThisReport + endFieldFontTag + " " + Scores + "." + subSectionBreak);
//				summaryReport.append(NCCP_R_ReferenceRange + sectionBreak);
//			} else {
//				summaryReport.append(painNCCPC_RScoreIs + summaryReportEs + " " + beginFieldFontTag + totalQOLThisReport
//						+ endFieldFontTag + " " + Scores + "." + subSectionBreak);
//				summaryReport.append(NCCP_R_ReferenceRange + sectionBreak);
//			}
//		} else
//			flag2 = 1;
			// summaryReport.append(noQolForRecentSurvey + sectionBreak);

			// old code with NCCPC-R Summary section
//		if (flag1 == 1 && flag2 == 1) {
//			summaryReport.append(noQolForRecentSurvey + sectionBreak);
//		}

			// new code after removing NCCPC-R Summary section
			if (flag1 == 1) {
				logger.debug("If NRS not reported in most recent survey...NRS does not answered... ");
				summaryReport.append(noQolForRecentSurvey + sectionBreak);
			}
		}

		// Comparison of todays pain numerical and pain numerical in previous
		// report
		// if(previousReport!=null)
		if (previousSurveyScore != null) {
			logger.debug("under the report comparision...when previousSurveyScore is not equal to null");
			// Map<String, ScoresDetails> previousReportScoresMap =
			// createScoreDetailsMapForSymptom(previousReport.getScoresInReport().get(previousReport.getScoresInReport().size()-1).getScorevalues());
			Map<String, Map<String, ScoresDetails>> previousReportScoresMap = createScoreDetailsMapForSymptom(
					previousSurveyScore.getScorevalues());
			Float totalPainNumericalLastReport = getPedQLScore(previousReportScoresMap, "NS");
			logger.debug("totalPainNumericalLastReport : " + totalPainNumericalLastReport);

			// Report pain numerical changes
			if ((NumericalScaleSummaryReport != null && !(NumericalScaleSummaryReport < 0))
					&& (totalPainNumericalLastReport != null && !(totalPainNumericalLastReport < 0))) {
				logger.debug("under the report comparision...NRS is answered");
				summaryReport.append(cmpToLastReport + "  " + beginFieldFontTag /* +"[" */
						+ rsPerson.getFirstName() /* +"]" */ + endFieldFontTag + " " + curPainNumericalScoreHas);
				String deviationTotalQOLString = null;
				Float deviationTotalQOL = NumericalScaleSummaryReport - totalPainNumericalLastReport;
				float roundedDeviationTotalQOL = deviationTotalQOL;
				roundedDeviationTotalQOL = Math.round(roundedDeviationTotalQOL * 10);
				roundedDeviationTotalQOL = roundedDeviationTotalQOL / 10;
//				if (deviationTotalQOL == 0)
				// not changed if nrs_change is between -2 and 2
				if (deviationTotalQOL > -2 && deviationTotalQOL < 2)
					deviationTotalQOLString = notChanges + " "/* + "\"]" */ + subSectionBreak;
//				else if (deviationTotalQOL < 0)
				// improved if nrs_change is a negative value -2
				else if (deviationTotalQOL <= -2)
					deviationTotalQOLString = " " + decreasedBy /* + " " + "\"]" + "  " + "1" */ + " " + by + " " /*
																													 * +
																													 * "["
																													 */
							+ beginFieldFontTag + Math.abs(roundedDeviationTotalQOL) + endFieldFontTag /* + "]" */ + " "
							+ points + subSectionBreak;
//				else if (deviationTotalQOL > 0)
				// Display worsened if nrs_change is a positive value 2
				else if (deviationTotalQOL >= 2)
					deviationTotalQOLString = " " + increasedBy /* + " " + "\"]" + "  " + "1" */ + " " + by + " "/*
																													 * +
																													 * "["
																													 */
							+ beginFieldFontTag + Math.abs(roundedDeviationTotalQOL) + endFieldFontTag/* + "]" */ + " "
							+ points + " " + subSectionBreak;
//				summaryReport.append(deviationTotalQOLString + " " + and + " ");
				// remove and
				summaryReport.append(deviationTotalQOLString + " ");

				StringBuffer functionDeviation = new StringBuffer();

				Long daysBetweenAdministrations = FunctionUtil.daysBetweenDates(
						reportData.getLatestQuestInstance().getEndDate(),
						previousSurveyScore.getQuestInstance().getEndDate());
				logger.debug("daysBetweenAdministrations : " + daysBetweenAdministrations);
				// if the two administrations are 30 days apart
				if (daysBetweenAdministrations > 30) {
					logger.debug("under the report comparision...if the two administrations are 30 days apart");
					summaryReport.append(subSectionBreak + pleaseNoteThat + " " + beginFieldFontTag
							+ rsPerson.getFirstName() + endFieldFontTag + " " + surveyAndministered + " "
							+ beginFieldFontTag + daysBetweenAdministrations + endFieldFontTag + " "
							+ daysBeforeCurrSurvey + sectionBreak);
				}

			} else {
				logger.debug("under the report comparision...NRS is not answered");
				flag3 = 1;

				if (flag3 == 1) {
					logger.debug("under the report comparision...NRS is not answered...underflag");
//				summaryReport.append(cmpToLastReport + beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " ");
					summaryReport.append(" ");
				}
			}
		}

		// comment code because we remove the NCCPC_R summary section from the graph
		// Comparison of todays NCCPC_R and NCCPC_R in previous report
		// if(previousReport!=null)
		// if (previousSurveyScore != null) {
		// Map<String, ScoresDetails> previousReportScoresMap =
		// createScoreDetailsMapForSymptom(previousReport.getScoresInReport().get(previousReport.getScoresInReport().size()-1).getScorevalues());
		// Map<String, Map<String, ScoresDetails>> previousReportScoresMap =
		// createScoreDetailsMapForSymptom(
		// previousSurveyScore.getScorevalues());
		// Float totalQOLLastReport = getPedQLScore(previousReportScoresMap,
		// "nccpcr_tot");

		// Report NCCPC_R changes
		// if (totalQOLThisReport != null && totalQOLLastReport != null) {
		// summaryReport.append(
		// /* cmpToLastReport+beginFieldFontTag+rsPerson.getFirstName()+endFieldFontTag+
		// */curQolScoreHas);
		// String deviationTotalQOLString = null;
		// Float deviationTotalQOL = totalQOLThisReport - totalQOLLastReport;
		// float roundedDeviationTotalQOL = deviationTotalQOL;
		// roundedDeviationTotalQOL = Math.round(roundedDeviationTotalQOL * 10);
		// roundedDeviationTotalQOL = roundedDeviationTotalQOL / 10;
		// if (deviationTotalQOL == 0)
		// deviationTotalQOLString = notChanges + " "/* + "\"]" */ + subSectionBreak;
		// else if (deviationTotalQOL < 0)
		// deviationTotalQOLString = " " + decreasedBy /* + " " + "\"]" + " " + "2" */ +
		// " " + by + " " /*
		// * +
		// * "["
		// */
		// + beginFieldFontTag + Math.abs(roundedDeviationTotalQOL) + endFieldFontTag /*
		// + "]" */ + " "
		// + points + subSectionBreak;
		// else if (deviationTotalQOL > 0)
		// deviationTotalQOLString = " " + increasedBy /* + " " + "\"]" + " " + "2" */ +
		// " " + by + " " /*
		// * +
		// * "["
		// */
		// + beginFieldFontTag + Math.abs(roundedDeviationTotalQOL) + endFieldFontTag/*
		// + "]" */ + " "
		// + points + " " + subSectionBreak;
		// summaryReport.append(deviationTotalQOLString);

//				StringBuffer functionDeviation = new StringBuffer();
//				if(deviationTotalQOL<= -10)
//				{
//	
//					Float thisReportScore = getPedQLScore(currentReportScoresMap,"pql_phys");
//					Float previousReportScore = getPedQLScore(previousReportScoresMap,"pql_phys");
//					if(thisReportScore!=null && previousReportScore!=null && (thisReportScore-previousReportScore)  <=-10)
//						functionDeviation.append(physical+" "); 
//					
//					thisReportScore = getPedQLScore(currentReportScoresMap,"pql_emot");
//					previousReportScore = getPedQLScore(previousReportScoresMap,"pql_emot");
//					if(thisReportScore!=null && previousReportScore!=null && (thisReportScore-previousReportScore)<=-10)
//						functionDeviation.append(emotional+" "); 
//					
//					thisReportScore = getPedQLScore(currentReportScoresMap,"pql_social");
//					previousReportScore = getPedQLScore(previousReportScoresMap,"pql_social");
//					if(thisReportScore!=null && previousReportScore!=null && (thisReportScore-previousReportScore)<=-10)
//						functionDeviation.append(social+" "); 
//					
//					thisReportScore = getPedQLScore(currentReportScoresMap,"pql_school");
//					previousReportScore = getPedQLScore(previousReportScoresMap,"pql_school");
//					if(thisReportScore!=null && previousReportScore!=null && (thisReportScore-previousReportScore)<=-10)
//						functionDeviation.append(school+" "); 
//					
//					if(functionDeviation.length()>0)
//					{
//						functionDeviation.setLength(functionDeviation.length()-2);
//						summaryReport.append(decreaseInQol+" "+beginFieldFontTag);
//						summaryReport.append(functionDeviation+endFieldFontTag+" "+functioning+" "+subSectionBreak);
//				}
//				}
		// }
		// Long daysBetweenAdministrations =
		// FunctionUtil.daysBetweenDates(reportData.getLatestQuestInstance().getEndDate(),
		// previousReport.getScoresInReport().get(previousReport.getScoresInReport().size()-1).getQuestInstance().getEndDate());
//			Long daysBetweenAdministrations = FunctionUtil.daysBetweenDates(
//					reportData.getLatestQuestInstance().getEndDate(),
//					previousSurveyScore.getQuestInstance().getEndDate());
//			// if the two administrations are 30 days apart
//			if (daysBetweenAdministrations > 30) {
//				logger.debug("under the report comparision...if the two administrations are 30 days apart");
//				summaryReport.append(subSectionBreak + pleaseNoteThat + " " + beginFieldFontTag
//						+ rsPerson.getFirstName() + endFieldFontTag + " " + surveyAndministered + " "
//						+ beginFieldFontTag + daysBetweenAdministrations + endFieldFontTag + " " + daysBeforeCurrSurvey
//						+ sectionBreak);
//			}
		// }
		/////////////////////////////////////////////////////////////////////////////////////////////
		// Symptoms that are not present in last month

		String symptomNotPresent = bundle.getString("report.dynamic.i18n.symptom.not.present");
		String symptomNotPresentNote = bundle.getString("report.dynamic.i18n.symptom.not.present.note");
		String symptomNotPresentText = bundle.getString("report.dynamic.i18n.symptom.not.present.text");
		String hasNoNewSymptoms = bundle.getString("report.dynamic.i18n.new.symptoms.for.first.time");
		String reortedThat = bundle.getString("report.dynamic.i18n.reported.that");

		if (reportData.getSymptomsNotPresent().size() > 0) {
			logger.debug("under the Symptoms that are not present in last month...");
			noTextUnderOtherSymptoms = Boolean.FALSE;
			if (languageCode.equals("en")) {
				summaryReport.append(subSectionBreak + beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag
						+ symptomNotPresent + " " + beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
						+ symptomNotPresentText + " " + beginFieldFontTag);
			} else {
				summaryReport.append(subSectionBreak + symptomNotPresent + " " + beginFieldFontTag
						+ rsPerson.getFirstName() + endFieldFontTag + " " + reortedThat + " " + beginFieldFontTag
						+ rsPerson.getFirstName() + endFieldFontTag + " " + symptomNotPresentText + " "
						+ beginFieldFontTag);
			}

			int i = 0;
			for (String s : reportData.getSymptomsNotPresent()) {
				if (i > 0)
					summaryReport.append("; ");
				// summaryReport.append(", ");

				else
					i++;
				summaryReport.append(s.toLowerCase().trim());
			}
			if (i > 0)
				summaryReport.append(endFieldFontTag + "." + subSectionBreak);
			// summaryReport.append(symptomNotPresentText + " " + subSectionBreak);
			// summaryReport.append(symptomNotPresentNote + " " + subSectionBreak);
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////
		// Report new symptoms -- Remove new Symptoms section from the Report
		// Remove new symptom section from the report 21/3/2024

//		summaryReport.append(subSectionBreak);
//
//		if (newOtherSymptoms.size() > 0 || reportData.getNewSymptoms().size() > 0) {
//
//			Map<String, Map<String, ScoresDetails>> currentNewSymptomsReportScoresMap = createScoreDetailsMapForSymptom(
//					reportData.getScoresInReport().get(reportData.getScoresInReport().size() - 1).getScorevalues());
//			Map<String, Map<String, ScoresDetails>> previousReportScoresMap = null;
//			if (previousSurveyScore != null) {
//				previousReportScoresMap = createScoreDetailsMapForSymptom(previousSurveyScore.getScorevalues());
//			}
//			List<PediCTRptSymptomGraphsMetadata> symptomlist = (List<PediCTRptSymptomGraphsMetadata>) FunctionUtil
//					.emptyIfNull(symptomMetadataDao.findAll());
//
//			String dataAddForNewSymptoms = "";
//			String newSymtomsData = "";
//			int flag = 0;
//			if (previousReportScoresMap != null) {
//				for (Entry<String, Map<String, ScoresDetails>> currentNewSymptoms : currentNewSymptomsReportScoresMap
//						.entrySet()) {
//					Map<String, ScoresDetails> currentNewSymptomsValue = currentNewSymptoms.getValue();
//					for (String currentKey : currentNewSymptomsValue.keySet()) {
//						flag = 0;
//						for (Entry<String, Map<String, ScoresDetails>> previousNewSymptoms : previousReportScoresMap
//								.entrySet()) {
//							Map<String, ScoresDetails> previousNewSymptomsValue = previousNewSymptoms.getValue();
//
//							for (String previoiusKey : previousNewSymptomsValue.keySet()) {
//								Float totalPainNumericalLastReport = getPedQLScore(previousReportScoresMap,
//										previoiusKey);
//								if (totalPainNumericalLastReport != null && totalPainNumericalLastReport >= 0) {
//									if (currentKey.equals(previoiusKey)) {
//
//										flag = 1;
//										break;
//									}
//								}
//
//							}
//							if (flag == 1)
//								break;
//
//						}
//						if (flag == 0) {
//							for (PediCTRptSymptomGraphsMetadata symtomList : symptomlist) {
//								if (currentKey.equals(symtomList.getBusinessRule())) {
//
//									dataAddForNewSymptoms = bundle.getString(symtomList.getDisplayName());
//									// newSymtomsData.concat(dataAddForNewSymptoms.toLowerCase()+"; ");
//									newSymtomsData = newSymtomsData + dataAddForNewSymptoms.toLowerCase() + ";";
//									// summaryReport.append(dataAddForNewSymptoms.toLowerCase()+"; ");
//								}
//							}
//						}
//
//					}
//				}
//			}
//			if (newSymtomsData != null && !newSymtomsData.equals("")) {
//				String str = "";
//				// if(reportData.getScoresInReport().size() == 1)
//				// {
//				str = beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " " + hasNewSymptoms + " "
//						+ subSectionBreak + beginFieldFontTag;
//				// }
//				// else
//				// {
//				// str = beginFieldFontTag+rsPerson.getFirstName()+endFieldFontTag+" "
//				// +hasNoNewSymptoms+" "+subSectionBreak+beginFieldFontTag;
//				// }
//				summaryReport.append(str);
//				summaryReport.append(" "/* +"[" */ + " " + newSymtomsData);
//			}
//
//			summaryReport.setLength(summaryReport.length() - 2);
//			// summaryReport.append(".");
//			summaryReport.append(/* " "+"]"+ */"." + endFieldFontTag + subSectionBreak);
//
//		}
//		/*
//		 * // Report new symptoms -- Remove new Symptoms section from the Report
//		 * 
//		 * summaryReport.append(subSectionBreak); if(newOtherSymptoms.size()>0 ||
//		 * reportData.getNewSymptoms().size()>0) { String str = "";
//		 * if(reportData.getScoresInReport().size() == 1) str =
//		 * beginFieldFontTag+rsPerson.getFirstName()+endFieldFontTag+" "
//		 * +hasNewSymptomsFirstTime+" "+subSectionBreak+beginFieldFontTag; else str =
//		 * beginFieldFontTag+rsPerson.getFirstName()+endFieldFontTag+" "
//		 * +hasNewSymptoms+" "+subSectionBreak+beginFieldFontTag;
//		 * 
//		 * summaryReport.append(str);
//		 * 
//		 * Map<String, Map<String, ScoresDetails>> previousReportScoresMap =
//		 * createScoreDetailsMapForSymptom(previousSurveyScore.getScorevalues());
//		 * 
//		 * 
//		 * 
//		 * for(String s: reportData.getNewSymptoms()) { Float
//		 * totalPainNumericalLastReport = getPedQLScore(previousReportScoresMap, s);
//		 * if(totalPainNumericalLastReport!=null) {
//		 * summaryReport.append(s.toLowerCase()+"; "); //} } for(String s:
//		 * newOtherSymptoms) { Float totalPainNumericalLastReport =
//		 * getPedQLScore(previousReportScoresMap, s);
//		 * 
//		 * if(totalPainNumericalLastReport!=null) {
//		 * summaryReport.append(s.toLowerCase()+"; "); // }
//		 * 
//		 * summaryReport.setLength(summaryReport.length()-2); summaryReport.append(".");
//		 * summaryReport.append(endFieldFontTag+subSectionBreak); } }
//		 */

		// Symptom/s with high distress
		summaryReport.append(subSectionBreak);
		StringBuffer highDistress = new StringBuffer();
		List<String> highDistressList = new ArrayList<String>();
		List<String> highDistressSortedList = new ArrayList<String>();

		for (ScoresDetails sd1 : reportData.getScoresInReport().get(reportData.getScoresInReport().size() - 1)
				.getScorevalues()) {
			// if ((sd1.getValue() != null) && (sd1.getScoreName().contains("avg")) &&
			// (sd1.getValue() >= 33)) {
			if (((sd1.getValue() != null) && (sd1.getScoreName().contains("avg")) && (sd1.getValue() >= 50))
					|| ((sd1.getValue() != null) && (sd1.getScoreName().contains("both")) && (sd1.getValue() >= 50))) {

				String displayName = "";
				if (sd1.getScoreName().contains("oth1") || sd1.getScoreName().contains("oth2")
						|| sd1.getScoreName().contains("oth3")) {
				} else {
					displayName = getAttributeDisplayName(sd1.getScoreName(), bundle);
					if (displayName != null && !highDistressList.contains(displayName)) {
						highDistressList.add(displayName);
//						highDistress.append(displayName.toLowerCase()+"; ");
					}
				}
			}

		}
           // uncomment code for bleeding- 27/3/24
		// highDistressSortedList.addAll(highDistressOthers);

		List<String> highDistressSymptomList = new ArrayList<String>();
		// Sort highDistressList based on graph.
		List<PediCTRptSymptomGraphsMetadata> symptomlist = (List<PediCTRptSymptomGraphsMetadata>) FunctionUtil
				.emptyIfNull(symptomMetadataDao.findAll());
		for (PediCTRptSymptomGraphsMetadata symptom : symptomlist) {
			if (highDistressList.contains(symptom.getDisplayName())
					&& !highDistressSortedList.contains(symptom.getDisplayName())) {
				// highDistressSortedList.add(bundle.getString(symptom.getDisplayName()));
				highDistressSymptomList.add(bundle.getString(symptom.getDisplayName()));
			}
		}

		highDistressSortedList.clear();
		// Iterate the list and replace the language wise content in the same list
		// uncomment code for bleeding- 27/3/24	lineNo- 3221 to 3225
		//  for (String highDistressSymptom : highDistressOthers) {
		  
		//  highDistressSortedList.add(bundle.getString(highDistressSymptom)); }
		 

		highDistressSortedList.addAll(highDistressSymptomList);
		// uncomment code for bleeding- 27/3/24
		// highDistressList.addAll(highDistressOthers);

		// REPORT I18N properties
		String havingModerateOrDiestress = bundle.getString("report.dynamic.i18n.having.moderare.or.distress");
		String plzNoteThat = bundle.getString("report.dynamic.i18n.note");

		Collections.sort(highDistressSortedList, new Comparator<String>() {
			public int compare(String s1, String s2) {
				return s1.compareToIgnoreCase(s2);
			}
		});

		// TODO : Add other symptoms list to highDistressSortedList here
		highDistressSortedList.addAll(othSymptomsForHighDistress);

		for (String highDistressName : highDistressSortedList) {
			String name = highDistressName.replace("<br/>", "");
			highDistress.append(name.toLowerCase() + "; ");
		}
		if (highDistressSortedList.size() > 0) {
			highDistress.setLength(highDistress.length() - 2);
			highDistress.append(".");
			logger.debug("under the If high distress");
			summaryReport.append(
					beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " " + havingModerateOrDiestress
							+ " <br/> " + beginFieldFontTag + highDistress + endFieldFontTag + subSectionBreak);
			// summaryReport.append(plzNoteThat + sectionBreak);
			 summaryReport.append(sectionBreak);
		} else {
			summaryReport.append(beginFieldFontTag + rsPerson.getFirstName() + endFieldFontTag + " "
					+ noModerateOrDistress + sectionBreak);
			logger.debug("under the If not high distress");
		}

		// Most bothersome problem If WB_bother question has text String
		String botherSomeText = bundle.getString("report.dynamic.i18n.mostbohtersome.text");
		String parentSectionCode = null;
		parentSectionCode = "WB_pf";
		String enteredText = null;
		logger.debug("parentSectionCode : " + parentSectionCode);

		Question question = null;
		Float averageScores = null;

		averageScores = Float.valueOf(-1);
		// check if the lead question was answered
		question = questionService.getQuestionByCodeForSection("WB_bother", parentSectionCode,
				parentsInstance.getQuestionnaire().getMainContainer().getId());
		if (question != null) {
			Answer answer = getAnswerForQuestion(parentsInstance, question);
			if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty()) {
				logger.debug("under the If bother question has text");
				enteredText = answer.getAnswerData().toLowerCase().trim();
				if (enteredText != null || !enteredText.isEmpty()) {
					summaryReport.append(botherSomeText + " " + beginFieldFontTag/* +"[" */
							+ rsPerson.getFirstName() /* +"]" */ + endFieldFontTag + " " + was + " " + beginFieldFontTag
							+ enteredText + "." + endFieldFontTag + subSectionBreak);
				}
			}

		}

		// Added one final open ended question

		String openendText = bundle.getString("report.dynamic.i18n.openend.text");
		String openendTextlast = bundle.getString("report.dynamic.i18n.openend.text.last");
		String parentSectionCode_openEnd = null;
		parentSectionCode_openEnd = "WB_pf";
		String enteredText_openEnd = null;
		logger.debug("parentSectionCode_openEnd : " + parentSectionCode_openEnd);

		Question question_openEnd = null;
		Float averageScores_openEnd = null;

		averageScores_openEnd = Float.valueOf(-1);

		// check if the open-ended question was answered
		question_openEnd = questionService.getQuestionByCodeForSection("WB_open", parentSectionCode_openEnd,
				parentsInstance.getQuestionnaire().getMainContainer().getId());
		if (question_openEnd != null) {
			Answer answer_openEnd = getAnswerForQuestion(parentsInstance, question_openEnd);
			if (answer_openEnd != null && answer_openEnd.getAnswerData() != null
					&& !answer_openEnd.getAnswerData().isEmpty()) {
				enteredText_openEnd = answer_openEnd.getAnswerData().toLowerCase().trim();

				if (enteredText_openEnd != null && !enteredText_openEnd.isEmpty()) {
					// If open_endquestion has text
					logger.debug("under the If open_endquestion has text");
					summaryReport.append(openendText + " " + beginFieldFontTag + enteredText_openEnd + "."
							+ endFieldFontTag + subSectionBreak);
				}
			}

			// if open ended question has not answered.
			else {
				// If open_end question has no text
				logger.debug("under the If open_end question has no text");
				summaryReport.append(openendText + " " + beginFieldFontTag + openendTextlast + "." + endFieldFontTag
						+ subSectionBreak);
			}

		}

		////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Add summary report to the report data
		reportData.setSummaryReport(summaryReport.toString());

	}

	private List<SymptomData> populateOtherSymptomsFromParentsLatestInstance(ReportRecord reportData,
			List<String> othSymptomsForHighDistress, List<String> newOtherSymptoms,
			Map<String, Map<String, ScoresDetails>> currentReportScoresMap, String languageCode) {
		QuestionnaireInstance parentsInstance = null;
		String parentSectionCode = null;
		List<SymptomData> otherChildSymptoms = new ArrayList<PediReportsServiceImpl.SymptomData>();

		logger.debug("Fetch other symptom answers from child latest survey (if survey is valid");
		// Get latest instance in report data and check rs type.
		// If RS is a caregiver then get its childs latest instance.
		QuestionnaireInstance latestInstance = reportData.getLatestQuestInstance();
		logger.debug("latestInstance Id : " + latestInstance.getId());
		if (latestInstance.getResearchSubject().getType() == ResearchSubjectType.PATIENT) {
			logger.info("Latest answered survey in report data was by patient");
			logger.info("Get parents latest answered survey");
			parentsInstance = getLatestOtherPartyInstance(latestInstance);
			if (parentsInstance == null)
				return otherChildSymptoms;
		} else {
			logger.info("Latest answered survey in report data was by parent");
			parentsInstance = latestInstance;
		}

		// If child latest answered survey is incomplete the return empty list.
		logger.info("Check if parent's answered survey is valid or not.");
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(parentsInstance.getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			if (pScore.getStatus() == PediScoreStatus.INCOMPLETESURVEY) {
				logger.info("childs survey is INCOMPLETESURVEY. Return empty list.");
				return otherChildSymptoms;
			}
		} else {
			throw new InconsistentDataException();
		}

		// Determine the section code from age group.
		parentSectionCode = "MSAS_pf";
		logger.debug("parentSectionCode : " + parentSectionCode);

		Question q = null;
		Float averageScore = null;

		averageScore = Float.valueOf(-1);
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_oth1", parentSectionCode,
				parentsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			Answer answer = getAnswerForQuestion(parentsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				q = null;
				q = questionService.getQuestionByCodeForSection("MSAS_oth1_symp", parentSectionCode,
						parentsInstance.getQuestionnaire().getMainContainer().getId());
				if (q != null) {
					answer = getAnswerForQuestion(parentsInstance, q);
					if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty())
					// if symptom was entered in the text box, read the average of the
					{
						ScoresDetails sd = currentReportScoresMap.get(parentSectionCode).get("oth1_avg");
						String textEntered = answer.getAnswerData().toLowerCase().trim();
						averageScore = sd.getValue();
						SymptomData s = new SymptomData();
						s.symptomName = textEntered;
						s.score = averageScore;
//						if (averageScore >= 33) {
						if (averageScore >= 50) {
							// highDistressOthers.add(textEntered);
							othSymptomsForHighDistress.add(textEntered);
						}
						otherChildSymptoms.add(s);
						newOtherSymptoms.add(textEntered);
						// othSymptomsForNewSymptoms.add(textEntered);
					}
				}
			}
		}

		// TO-DO do this for oth2 and oth3
		averageScore = Float.valueOf(-1);
		q = null;
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_oth2", parentSectionCode,
				parentsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			logger.debug("Other2 question loacated in section:" + parentSectionCode);
			Answer answer = getAnswerForQuestion(parentsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				logger.debug("Other2 question answer found");
				q = null;
				q = questionService.getQuestionByCodeForSection("MSAS_oth2_symp", parentSectionCode,
						parentsInstance.getQuestionnaire().getMainContainer().getId());
				if (q != null) {
					answer = getAnswerForQuestion(parentsInstance, q);
					if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty())
					// if symptom was entered in the text box, read the average of the
					{
						logger.debug("Other2 question answer found for symptom question");
						ScoresDetails sd = currentReportScoresMap.get(parentSectionCode).get("oth2_avg");
						String textEntered = answer.getAnswerData().toLowerCase().trim();
						averageScore = sd.getValue();
						SymptomData s = new SymptomData();
						s.symptomName = textEntered;
						s.score = averageScore;
//						if (averageScore >= 33) {
						if (averageScore >= 50) {
							// highDistressOthers.add(textEntered);
							othSymptomsForHighDistress.add(textEntered);
						}
						otherChildSymptoms.add(s);
						newOtherSymptoms.add(textEntered);
						// othSymptomsForNewSymptoms.add(textEntered);
					}
				}
			}
		}

		averageScore = Float.valueOf(-1);
		q = null;
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_oth3", parentSectionCode,
				parentsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			logger.debug("Other3 question loacated in section:" + parentSectionCode);
			Answer answer = getAnswerForQuestion(parentsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				logger.debug("Other3 question answer found");
				q = null;
				q = questionService.getQuestionByCodeForSection("MSAS_oth3_symp", parentSectionCode,
						parentsInstance.getQuestionnaire().getMainContainer().getId());
				if (q != null) {
					answer = getAnswerForQuestion(parentsInstance, q);
					if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty())
					// if symptom was entered in the text box, read the average of the
					{
						logger.debug("Other3 question answer found for symptom question");
						ScoresDetails sd = currentReportScoresMap.get(parentSectionCode).get("oth3_avg");
						String textEntered = answer.getAnswerData().toLowerCase().trim();
						averageScore = sd.getValue();
						SymptomData s = new SymptomData();
						s.symptomName = textEntered;
						s.score = averageScore;
//						if (averageScore >= 33) {
						if (averageScore >= 50) {
							// highDistressOthers.add(textEntered);
							othSymptomsForHighDistress.add(textEntered);
						}

						otherChildSymptoms.add(s);
						newOtherSymptoms.add(textEntered);
						// othSymptomsForNewSymptoms.add(textEntered);
					}
				}
			}
		}
		// TO-DO do this for bleeding
		averageScore = Float.valueOf(-1);
		q = null;
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_bleed", parentSectionCode,
				parentsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			logger.debug("bleeding question loacated in section:" + parentSectionCode);
			Answer answer = getAnswerForQuestion(parentsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				logger.debug("bleeding question answer found");
				// q = null;
				// q = questionService.getQuestionByCodeForSection("MSAS_oth2_symp",
				// parentSectionCode,parentsInstance.getQuestionnaire().getMainContainer().getId());
				// if(q!=null){
				// answer = getAnswerForQuestion(parentsInstance,q);
				// if (answer!=null && answer.getAnswerData()!=null &&
				// !answer.getAnswerData().isEmpty())
				// if symptom was entered in the text box, read the average of the
				// {
				ResourceBundle bundle = null;
				/*
				 * if(languageCode == 2) bundle = ResourceBundle.getBundle("messages", new
				 * Locale("es")); else bundle = ResourceBundle.getBundle("messages", new
				 * Locale("en"));
				 */
				logger.debug("Getting bundle for language Code : " + languageCode);
				bundle = ResourceBundle.getBundle("messages", new Locale(languageCode));
				if (bundle == null) {
					logger.debug("Bundle not found for language code : " + languageCode);
					logger.info("Loading English bundle");
					bundle = ResourceBundle.getBundle("messages", new Locale("en"));
				}
				String bleedingText = bundle.getString("report.dynamic.i18n.bleeding");
				logger.debug("average calculation for bleeding");
				ScoresDetails sd = currentReportScoresMap.get(parentSectionCode).get("bleed_avg" + "");
				// String textEntered = answer.getAnswerData().toLowerCase().trim();
				averageScore = sd.getValue();
				SymptomData s = new SymptomData();
				s.symptomName = bleedingText;
				s.score = averageScore;
//				if (averageScore >= 33) {
				if (averageScore >= 50) {
					// highDistressOthers.add(textEntered);
					// othSymptomsForHighDistress.add("bleeding");
					 othSymptomsForHighDistress.add(bleedingText);
				}
				otherChildSymptoms.add(s);
				newOtherSymptoms.add(bleedingText);
				// othSymptomsForNewSymptoms.add(textEntered);
				// }
				// }
			}
		}

		return otherChildSymptoms;
	}

	private List<SymptomData> populateOtherSysmptomsFromChildsLatestInstance(ReportRecord reportData,
			List<String> othSymptomsForHighDistress, List<String> newOtherSymptoms,
			Map<String, Map<String, ScoresDetails>> currentReportScoresMap) {

		QuestionnaireInstance childsInstance = null;
		String childSectionCode = null;
		List<SymptomData> otherChildSymptoms = new ArrayList<PediReportsServiceImpl.SymptomData>();

		logger.debug("Fetch other symptom answers from child latest survey (if survey is valid");
		// Get latest instance in report data and check rs type.
		// If RS is a caregiver then get its childs latest instance.
		// Else take the latest instance which will be child's
		QuestionnaireInstance latestInstance = reportData.getLatestQuestInstance();
		logger.debug("latestInstance Id : " + latestInstance.getId());
		if (latestInstance.getResearchSubject().getType() == ResearchSubjectType.CAREGIVER) {
			logger.info("Latest answered survey in report data was by parent");
			logger.info("Get childs latest answered survey when the age group is 8-12 or 13+");
			if (latestInstance.getQuestionnaire().getHl7Entity().getCode().contains("8-12")
					|| latestInstance.getQuestionnaire().getHl7Entity().getCode().contains("13plus")) {
				childsInstance = getLatestOtherPartyInstance(latestInstance);
			} else if (latestInstance.getQuestionnaire().getHl7Entity().getCode().contains("7")) {
				logger.info("childs latest survey is parent's survey for 7");
				childsInstance = latestInstance;
			} else {
				logger.info("For other age groups there are not other symptom questions. Hence returning");
				// For 2 - 4 and 5 -6 there are no other symptom questions for the child
				return otherChildSymptoms;
			}
			// This case will only occur when we could not determine counter part survey for
			// the parent's survey. This will only happen when
			// child does not answer the survey enough.
			if (childsInstance == null) {
				logger.info("Child did not complete his survey. hence returning");
				return otherChildSymptoms;
			}
		} else {
			logger.info("Latest answered survey in report data was by child");
			childsInstance = latestInstance;
		}

		// If child latest answered survey is incomplete the return empty list.
		logger.info("Check if childs answered survey is valid or not.");
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(childsInstance.getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			if (pScore.getStatus() == PediScoreStatus.INCOMPLETESURVEY) {
				logger.info("childs survey is INCOMPLETESURVEY. Return empty list.");
				return otherChildSymptoms;
			}
		} else {
			throw new InconsistentDataException();
		}

		// If age group is 2 to 4 or 5 yo 6 then return empty list

		// Determine the section code from age group.
		logger.debug("Determine child section if MSAS_yc or MSAS_oc"); // TO-DO

		if (childsInstance.getResearchSubject().getAgeGroup() == null) {
			childSectionCode = "MSAS_yc";
		} else {
			if (childsInstance.getResearchSubject().getAgeGroup().getName().contains("13 and above"))
				childSectionCode = "MSAS_oc";
			else if (childsInstance.getResearchSubject().getAgeGroup().getName().contains("2 to 4")
					|| childsInstance.getResearchSubject().getAgeGroup().getName().contains("5 to 6")) {
				logger.debug("Age group is below 7. Return empty list");
				return otherChildSymptoms;
			} else
				childSectionCode = "MSAS_yc";
		}

		logger.debug("childSectionCode : " + childSectionCode);

		// We don't need this code.
		/*
		 * logger.debug("Get latest score"); Score latestScore =
		 * reportData.getScoresInReport().get(reportData.getScoresInReport().size()-1);
		 * List<String> pediSectionCodes = getPediSectionsInSurvey(latestScore);
		 * logger.debug("pediSectionCodes : "+pediSectionCodes.toString());
		 */

		Question q = null;
		Float averageScore = null;

		averageScore = Float.valueOf(-1);
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_oth1", childSectionCode,
				childsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			Answer answer = getAnswerForQuestion(childsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				q = null;
				q = questionService.getQuestionByCodeForSection("MSAS_oth1_symp", childSectionCode,
						childsInstance.getQuestionnaire().getMainContainer().getId());
				if (q != null) {
					answer = getAnswerForQuestion(childsInstance, q);
					if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty())
					// if symptom was entered in the text box, read the average of the
					{
						ScoresDetails sd = currentReportScoresMap.get(childSectionCode).get("oth1_avg");
						String textEntered = answer.getAnswerData().toLowerCase().trim();
						averageScore = sd.getValue();
						SymptomData s = new SymptomData();
						s.symptomName = textEntered;
						s.score = averageScore;
//						if (averageScore >= 33) {
						if (averageScore >= 50) {
							// highDistressOthers.add(textEntered);
							othSymptomsForHighDistress.add(textEntered);
						}
						otherChildSymptoms.add(s);
						newOtherSymptoms.add(textEntered);
						// othSymptomsForNewSymptoms.add(textEntered);
					}
				}
			}
		}

		// TO-DO do this for oth2 and oth3
		averageScore = Float.valueOf(-1);
		q = null;
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_oth2", childSectionCode,
				childsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			logger.debug("Other2 question loacated in section:" + childSectionCode);
			Answer answer = getAnswerForQuestion(childsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				logger.debug("Other2 question answer found");
				q = null;
				q = questionService.getQuestionByCodeForSection("MSAS_oth2_symp", childSectionCode,
						childsInstance.getQuestionnaire().getMainContainer().getId());
				if (q != null) {
					answer = getAnswerForQuestion(childsInstance, q);
					if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty())
					// if symptom was entered in the text box, read the average of the
					{
						logger.debug("Other2 question answer found for symptom question");
						ScoresDetails sd = currentReportScoresMap.get(childSectionCode).get("oth2_avg");
						String textEntered = answer.getAnswerData().toLowerCase().trim();
						averageScore = sd.getValue();
						SymptomData s = new SymptomData();
						s.symptomName = textEntered;
						s.score = averageScore;
//						if (averageScore >= 33) {
						if (averageScore >= 50) {
							// highDistressOthers.add(textEntered);
							othSymptomsForHighDistress.add(textEntered);
						}
						otherChildSymptoms.add(s);
						newOtherSymptoms.add(textEntered);
						// othSymptomsForNewSymptoms.add(textEntered);
					}
				}
			}
		}

		averageScore = Float.valueOf(-1);
		q = null;
		// check if the lead question was answered
		q = questionService.getQuestionByCodeForSection("MSAS_oth3", childSectionCode,
				childsInstance.getQuestionnaire().getMainContainer().getId());
		if (q != null) {
			logger.debug("Other3 question loacated in section:" + childSectionCode);
			Answer answer = getAnswerForQuestion(childsInstance, q);
			if (answer != null && answer.getAnswerStatus() == AnswerStatus.ANSWERED
					&& answer.getOptionChoosen().iterator().hasNext() && (answer.getOptionChoosen().iterator().next()
							.getHl7Entity().getCode().equalsIgnoreCase("MSAS_y")))
			// if lead question was answered, check if symptom was entered in the text box
			{
				logger.debug("Other3 question answer found");
				q = null;
				q = questionService.getQuestionByCodeForSection("MSAS_oth3_symp", childSectionCode,
						childsInstance.getQuestionnaire().getMainContainer().getId());
				if (q != null) {
					answer = getAnswerForQuestion(childsInstance, q);
					if (answer != null && answer.getAnswerData() != null && !answer.getAnswerData().isEmpty())
					// if symptom was entered in the text box, read the average of the
					{
						logger.debug("Other3 question answer found for symptom question");
						ScoresDetails sd = currentReportScoresMap.get(childSectionCode).get("oth3_avg");
						String textEntered = answer.getAnswerData().toLowerCase().trim();
						averageScore = sd.getValue();
						SymptomData s = new SymptomData();
						s.symptomName = textEntered;
						s.score = averageScore;
//						if (averageScore >= 33) {
						if (averageScore >= 50) {
							// highDistressOthers.add(textEntered);
							othSymptomsForHighDistress.add(textEntered);
						}

						otherChildSymptoms.add(s);
						newOtherSymptoms.add(textEntered);
						// othSymptomsForNewSymptoms.add(textEntered);
					}
				}
			}
		}

		return otherChildSymptoms;
	}

	private QuestionnaireInstance getLatestOtherPartyInstance(QuestionnaireInstance latestInstance) {
		Score counterPartScore = null;
		List<PediScore> pediScores = pediScoreDao.findPediScoreForQuestionniareInstance(latestInstance.getId());
		if (pediScores.size() == 1 && pediScores.get(0) != null) {
			PediScore pScore = pediScores.get(0);
			counterPartScore = pScore.getCounterPartScore();
			if (counterPartScore != null)
				return counterPartScore.getQuestInstance();
		}

		return null;
	}

	private boolean allSymptomScaleZero(String bleedingDistressScaleParent, String seizuresDistressScaleParent,
			String anorexDistressScaleParent, String sleepDistressScaleParent, ResourceBundle bundle) {
		if (!bleedingDistressScaleParent.equals(bundle.getString("MSAS_SUB_QUESTION_0")))
			return false;

		if (!seizuresDistressScaleParent.equals(bundle.getString("MSAS_SUB_QUESTION_0")))
			return false;

		if (!anorexDistressScaleParent.equals(bundle.getString("MSAS_SUB_QUESTION_0")))
			return false;

		if (!sleepDistressScaleParent.equals(bundle.getString("MSAS_SUB_QUESTION_0")))
			return false;

		return true;
	}

	private String getTextForAnswerValue(Float value, ResourceBundle bundle) {
		// String str = String.valueOf(value);
		Integer i = value.intValue();
		String finalStr = String.valueOf(i);
		return bundle.getString("MSAS_SUB_QUESTION_" + finalStr);
	}

	private Float getPedQLScore(Map<String, Map<String, ScoresDetails>> scoresMap, String key) {

		Log.debug("Get the PQL score for:" + key);
		Log.debug("Checking if the score is present:" + key);
		for (String sectionCode : QOLSectionCodes) {
			Log.debug("Checking the section code:" + sectionCode);
			// Check if the section is present in the survey
			if (scoresMap.get(sectionCode) != null) {
				Log.debug("Section was located in the survey");
				// Check if the key is found
				if (scoresMap.get(sectionCode).get(key) != null) {
					Log.debug("Score is present with the value:" + scoresMap.get(sectionCode).get(key).getValue());
					Log.debug("Returning");
					return scoresMap.get(sectionCode).get(key).getValue();

				}
			}
		}
		Log.debug("No score was located in any of the sections");
		return null;
	}

	private PediCTReportsContents createReport(List<ReportRecord> reportDataList, Patient patient,
			ResearchSubject patientRS, String languageCode, String reportPDFFolderPath, EmailRecord emailRecord)
			throws Exception {
		// Generate Report
		Integer reportId = null;
		// String path = "C:/pedireports_dev_v2";
		String path = reportPDFFolderPath;
		logger.debug("Report base path - " + reportPDFFolderPath);
		Map<String, Object> parameters = new HashMap<String, Object>();
		parameters.put("SUBREPORT_DIR", path + "/");
		ReportRecord reportData = reportDataList.get(0);
		File destFile = null;
		File sourceFile = null;
		PediCTReportsContents content = new PediCTReportsContents();
		PediCTReportsContents savedContent = null;
		// PediCTReports report = null;
		try {
			String pattern = "yyyy_MM_dd_hh_mm_ss";
			SimpleDateFormat format = new SimpleDateFormat(pattern);
			Date reportDate = Calendar.getInstance().getTime();
			String reportName = patient.getPerson().getLastName() + "_" + patient.getPerson().getFirstName() + "_"
					+ reportData.getPatientMRN() + "_" + format.format(reportDate) + ".pdf";

			logger.debug("Generating Report");
			// Locale locale = new Locale("en","es");
			// ResourceBundle rb = ResourceBundle.getBundle("messages", locale);
			// parameters.put(JRParameter.REPORT_RESOURCE_BUNDLE, rb);
			JRDataSource datasource = new JRBeanCollectionDataSource(reportDataList);

			ResourceBundle bundle = null;
			/*
			 * if(languageCode == 2) { bundle = ResourceBundle.getBundle("messages", new
			 * Locale("es")); parameters.put(JRParameter.REPORT_LOCALE, new Locale("es"));
			 * logger.debug("Message in "+" Spanish "
			 * +":"+bundle.getString("report.i18n.Symptom")); } else { bundle =
			 * ResourceBundle.getBundle("messages", new Locale("en"));
			 * parameters.put(JRParameter.REPORT_LOCALE, new Locale("en"));
			 * logger.debug("Message in "+" English "
			 * +":"+bundle.getString("report.i18n.Symptom")); }
			 */
			logger.debug("Loading bundle for language code : " + languageCode);
			bundle = ResourceBundle.getBundle("messages", new Locale(languageCode));
			if (bundle == null) {
				bundle = ResourceBundle.getBundle("messages", new Locale("en"));
				parameters.put(JRParameter.REPORT_LOCALE, new Locale("en"));
			} else
				parameters.put(JRParameter.REPORT_LOCALE, new Locale(languageCode));

			parameters.put(JRParameter.REPORT_RESOURCE_BUNDLE, bundle);
			JasperFillManager.fillReportToFile(path + "/PEDIMainReport.jasper", parameters, datasource);
			sourceFile = new File(path + "/PEDIMainReport.jrprint");

			logger.debug("Source file path - " + sourceFile);
			JasperPrint jasperPrint = (JasperPrint) JRLoader.loadObject(sourceFile);
			// This is the file that needs to be mailed
			destFile = new File(path + "/" + reportName);

			JRPdfExporter pdfExporter = new JRPdfExporter();

			pdfExporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);
			pdfExporter.setParameter(JRExporterParameter.OUTPUT_FILE_NAME, destFile.toString());

			pdfExporter.exportReport();

			FileInputStream fin = new FileInputStream(destFile);
			byte[] pdfBytes = new byte[(int) destFile.length()];
			fin.read(pdfBytes);

			fin.close();
			fin = null;
			logger.debug("report created at: " + destFile.getAbsolutePath());

			content.setReportPDF(pdfBytes);
			content.setReportCreatedAt(Calendar.getInstance());
			content.setLangugageCode(languageCode);
			savedContent = pediCTReportContentsDao.persist(content);
			// to send push notification
			// User user = patientRS.getPerson().getUser();

			// pushNotificationService.sendNotificationAfterReportCreated(report.getId(),user.getId(),PushNotificationConstants.ReportCreatedNotificationCode);

			// Set<Provider> providerList=patient.getProviders();
			// to send notification to providers of patient
			/*
			 * List<Provider>
			 * providerList=providerDao.findAllProviderByPatientId(patient.getId());
			 */
			/*
			 * if(providerList !=null) { for(Provider provider: providerList) {
			 * pushNotificationService.sendNotificationToProviderAfterReportCreated(report.
			 * getId(),provider.getPerson().getUser().getId(),patient.getId(),
			 * PushNotificationConstants.ReportCreatedForProviderNotificationCode); } }
			 */

			Boolean reportEmailed = false;
			/*
			 * if(languageCode.equals("en")) {
			 */
			// excelsheet send with email FOR NCCCPC-R
			String forEmailreportName = patient.getPerson().getLastName() + "_" + patient.getPerson().getFirstName()
					+ "_" + reportData.getPatientMRN() + "_" + format.format(reportDate);
			logger.debug("emailRecordList" + emailRecord);
			// delete NCCPC-R scoring rule 7/3/24
//		    String	excelFileLocalPath  =	createAndLoadExcelsheetForNCCCPC_R(emailRecord,forEmailreportName,languageCode);
			createAndLoadExcelsheetForNCCCPC_R(emailRecord, forEmailreportName, languageCode);

			/*
			 * FileInputStream finexcelFileLocalPath = new
			 * FileInputStream(excelFileLocalPath); byte[] excelBytes = new byte[(int)
			 * excelFileLocalPath.length()]; finexcelFileLocalPath.read(excelBytes);
			 * 
			 * finexcelFileLocalPath.close(); finexcelFileLocalPath = null;
			 * logger.debug("excel  created at: " + finexcelFileLocalPath);
			 */

			// delete NCCPC-R scoring rule 7/3/24
			// File file = new File(excelFileLocalPath);
			// FileInputStream fis = new FileInputStream(file);
			// Workbook workbook = WorkbookFactory.create(fis);

			// Convert the Excel file to a byte array
			// ByteArrayOutputStream baos = new ByteArrayOutputStream();
			// workbook.write(baos);
			// byte[] excelBytes = baos.toByteArray();

			// Do something with the byte array
			// ...

			// Close the resources
			// fis.close();
			// baos.close();
			// workbook.close();

			// delete NCCPC-R scoring rule 7/3/24
//			reportEmailed = emailReportToPatientAndCaregiver(destFile, reportData, patient, pdfBytes, path, reportName,
//					languageCode, bundle, excelFileLocalPath,excelBytes);
			reportEmailed = emailReportToPatientAndCaregiver(destFile, reportData, patient, pdfBytes, path, reportName,
					languageCode, bundle);
			/* } */

			/*
			 * if(languageCode.equals(patientRS.getLanguagePreference().getCodedEntity().
			 * getCode())) { reportEmailed =
			 * emailReportToPatientAndCaregiver(destFile,reportData,patient,pdfBytes, path,
			 * reportName); }
			 */

			if (reportEmailed) {
				savedContent.setStatus(PediCTReportStatus.ReportEmailed);
				savedContent.setReportEmailedAt(Calendar.getInstance());
			} else
				savedContent.setStatus(PediCTReportStatus.PDFCreated);

			savedContent = pediCTReportContentsDao.update(savedContent);

			// delete files once report is emailed
			/*
			 * if(destFile.exists() && destFile.canWrite()) destFile.delete();
			 */
			if (sourceFile.exists() && sourceFile.canWrite())
				sourceFile.delete();

			// sendNotification(reportData,patient,report.getId());
		} catch (Exception e) {
//				logger.error(e, e);
			System.out.println("************************************************");
			e.printStackTrace();
			// delete report files if there was an exception
			if (destFile != null && destFile.exists() && destFile.canWrite())
				destFile.delete();
			if (sourceFile != null && sourceFile.exists() && sourceFile.canWrite())
				sourceFile.delete();

			/*
			 * if(report != null && report.getId() != null) {
			 * sendNotification(reportData,patient,report.getId()); }
			 */
			logger.error("ERROR-PEDIQUEST: An exception has occured while creating report for patient id ="
					+ patient.getId() + ", PatientRS RsId = " + patientRS.getRsId());
			List<CRC> crcForPediQUESTStudy = (List<CRC>) FunctionUtil
					.emptyIfNull(crcService.searchByStudySiteName(patientRS.getStudySite().getName()));
			if (crcForPediQUESTStudy.isEmpty()) {
				logger.error(
						"ERROR-PEDIQUEST: CRCForPediQUESTStudy is empty so cannot send ReportingErrorToCRC for patient id ="
								+ patient.getId() + ", PatientRS RsId = " + patientRS.getRsId());
				throw new NoCRCForStudyException();
			}
			if (crcForPediQUESTStudy.get(0) != null && crcForPediQUESTStudy.get(0).getPerson() != null
					&& crcForPediQUESTStudy.get(0).getPerson().getUser() != null
					&& crcForPediQUESTStudy.get(0).getPerson().getUser().getUserRegistrationDetails() != null
					&& crcForPediQUESTStudy.get(0).getPerson().getUser().getUserRegistrationDetails()
							.getUserRegistrationMode().equals(UserRegistrationMode.BYMAIL))
				errorTOCRCService.sendReportingErrorToCRC(
						MailUtil.getActiveEmailAddress(crcForPediQUESTStudy.get(0).getPerson().getEmails()),
						"CRC Of PediQUEST Study", reportData.getLatestQuestInstance().getId(), patientRS.getRsId(),
						reportData.getLatestQuestInstance().getQuestionnaire().getQuestionnaireAbbrev());
			throw e;
		}
		return savedContent;
	}

	public void sendNotification(ReportRecord reportData, Patient patient, Integer reportId) {
		try {
			Integer studyId = reportData.getLatestQuestInstance().getResearchSubject().getStudySite().getStudy()
					.getId();
			// Send report to all the enrolled providers
			Set<Provider> providers = patient.getProviders();
			for (Provider p : providers) {
				List<PediResearchSubject> listProvidersPediRS = pediResearchSubjectDao.findByStudyProviderId(studyId,
						p.getId());
				if (listProvidersPediRS == null || listProvidersPediRS.size() == 0) {
				} else {
					pushNotificationService.sendNotificationAfterReportCreated(reportId,
							p.getPerson().getUser().getId(), PushNotificationConstants.ReportCreatedNotificationCode);
				}
			}

			Set<Caregiver> caregivers = patient.getCaregivers();
			for (Caregiver c : caregivers) {
				List<PediResearchSubject> listCaregiverPediRS = pediResearchSubjectDao.findByStudyCaregiverId(studyId,
						c.getId());
				if (listCaregiverPediRS == null || listCaregiverPediRS.size() == 0) {
				} else {
					pushNotificationService.sendNotificationAfterReportCreated(reportId,
							c.getPerson().getUser().getId(), PushNotificationConstants.ReportCreatedNotificationCode);
				}
			}

			// Send report to the patient
			pushNotificationService.sendNotificationAfterReportCreated(reportId, patient.getPerson().getUser().getId(),
					PushNotificationConstants.ReportCreatedNotificationCode);

		} catch (SessionNotFoundException e) {
			logger.error(e.getMessage(), e);
			logger.error(e.getMessage());
		} catch (SessionIsDeactiveException e) {
			logger.error(e.getMessage(), e);
			logger.error(e.getMessage());
		} catch (SessionIsInactiveException e) {
			logger.error(e.getMessage(), e);
			logger.error(e.getMessage());
		} catch (FCMSendMessageFailed e) {
			logger.error(e.getMessage(), e);
			logger.error(e.getMessage());
		}
	}

	// delete NCCPC-R scoring rule 7/3/24
//	private Boolean emailReportToPatientAndCaregiver(File destFile, ReportRecord reportData, Patient patient,
//			byte[] pdfBytes, String reporFilePath, String reportName, String languageCode, ResourceBundle bundle, String excelFileLocalPath,byte[] excelBytes)
//			throws Exception {
	private Boolean emailReportToPatientAndCaregiver(File destFile, ReportRecord reportData, Patient patient,
			byte[] pdfBytes, String reporFilePath, String reportName, String languageCode, ResourceBundle bundle)
			throws Exception {
		Boolean reportEmailed = Boolean.FALSE;
		try {
			reporFilePath = reporFilePath + "/" + reportName;

			Integer studyId = reportData.getLatestQuestInstance().getResearchSubject().getStudySite().getStudy()
					.getId();
			boolean alert = false;

			// Send report to the patient
			List<PediResearchSubject> listPrs = pediResearchSubjectDao
					.findByPersonIdStudyId(patient.getPerson().getId(), studyId);
			PediResearchSubject prs = listPrs.get(0);
			// MRUDUL: == operator was used to compare Integers in ENUM-
			// prs.getParticipantStudyStatus().getId() ==
			// ParticipantStudyStatus.ACTIVE.getId()
			if (prs.getParticipantStudyStatus().getId().compareTo(ParticipantStudyStatus.ACTIVE.getId()) == 0) {
				if (prs.isSendReports()) {
					try {

						// if(prs.getRegMode() == registrationMode.BYMAIL)
						if (prs.getPerson().getEmails() != null && !prs.getPerson().getEmails().isEmpty()
								&& bundle.getString(prs.getLanguagePreference().getCodedEntity().getDisplayName())
										.equals(languageCode)
								&& MailUtil.isEmailVerified(prs.getPerson().getEmails())) {

							// delete NCCPC-R scoring rule 7/3/24
//							emailReportsService.sendReport(patient.getPerson(), destFile, ResearchSubjectType.PATIENT,
//									alert, patient.getPerson(), studyId, pdfBytes, reporFilePath, reportName,excelFileLocalPath,excelBytes);

							emailReportsService.sendReport(patient.getPerson(), destFile, ResearchSubjectType.PATIENT,
									alert, patient.getPerson(), studyId, pdfBytes, reporFilePath, reportName);
							reportEmailed = Boolean.TRUE;
						}

					} catch (Exception e) {
						logger.error(
								"ERROR-PEDIQUEST: An exception has occured while sending a report email to patient with Id="
										+ patient.getId() + e.getMessage());
						logger.error(e.getMessage(), e);
					}
				}

				// Send report to all the enrolled caregivers
				Set<Caregiver> caregivers = patient.getCaregivers();
				for (Caregiver c : caregivers) {
					try {
						List<PediResearchSubject> listCaregiverPediRS = pediResearchSubjectDao
								.findByStudyCaregiverId(studyId, c.getId());
						if (listCaregiverPediRS == null || listCaregiverPediRS.size() == 0) {
							throw new Exception("PediResearchSubject list does not contain any item.");
						}
						PediResearchSubject caregiverPediRS = listCaregiverPediRS.get(0);

						// pushNotificationService.sendNotificationAfterReportCreated(reportId,c.getPerson().getUser().getId(),PushNotificationConstants.ReportCreatedNotificationCode);
						// Send Report to caregiver only when sendReports is true

						// MRUDUL: == operator was used to compare Integers in ENUM-
						// caregiverPediRS.getParticipantStudyStatus().getId() ==
						// ParticipantStudyStatus.ACTIVE.getId()
						if (caregiverPediRS.isSendReports() && caregiverPediRS.getParticipantStudyStatus().getId()
								.compareTo(ParticipantStudyStatus.ACTIVE.getId()) == 0) {
							// if(caregiverPediRS.getRegMode() == registrationMode.BYMAIL)
							if (caregiverPediRS.getPerson().getEmails() != null
									&& !caregiverPediRS.getPerson().getEmails().isEmpty()
									&& bundle.getString(
											caregiverPediRS.getLanguagePreference().getCodedEntity().getDisplayName())
											.equals(languageCode)
									&& MailUtil.isEmailVerified(caregiverPediRS.getPerson().getEmails())) {
								// delete NCCPC-R scoring rule 7/3/24
//								emailReportsService.sendReport(c.getPerson(), destFile, ResearchSubjectType.CAREGIVER,
//										alert, patient.getPerson(), studyId, pdfBytes, reporFilePath, reportName,excelFileLocalPath,excelBytes);
								emailReportsService.sendReport(c.getPerson(), destFile, ResearchSubjectType.CAREGIVER,
										alert, patient.getPerson(), studyId, pdfBytes, reporFilePath, reportName);
								reportEmailed = Boolean.TRUE;
							}
						}
					} catch (Exception e) {
						logger.error(
								"ERROR-PEDIQUEST: An exception has occured while sending a report email to Caregiver with Id="
										+ c.getId() + e.getMessage());
						logger.error(e.getMessage(), e);
					}

				}

				// Send report to all the enrolled providers
				Set<Provider> providers = patient.getProviders();
				for (Provider p : providers) {
					try {
						List<PediResearchSubject> listProvidersPediRS = pediResearchSubjectDao
								.findByStudyProviderId(studyId, p.getId());
						if (listProvidersPediRS == null || listProvidersPediRS.size() == 0) {
							throw new Exception("Reaserch subject list does not contain any item.");
						}
						PediResearchSubject providerPediRS = listProvidersPediRS.get(0);

						// MRUDUL: == operator was used to compare Integers in ENUM-
						// providerPediRS.getParticipantStudyStatus().getId() ==
						// ParticipantStudyStatus.ACTIVE.getId()
						if (providerPediRS.isSendReports() && providerPediRS.getParticipantStudyStatus().getId()
								.compareTo(ParticipantStudyStatus.ACTIVE.getId()) == 0) {
							// if(providerPediRS.getRegMode() == registrationMode.BYMAIL)
							if (providerPediRS.getPerson().getEmails() != null
									&& !providerPediRS.getPerson().getEmails().isEmpty() && languageCode.equals("en")
									&& MailUtil.isEmailVerified(providerPediRS.getPerson().getEmails())) {
								// delete NCCPC-R scoring rule 7/3/24
//								emailReportsService.sendReport(p.getPerson(), destFile, ResearchSubjectType.PROVIDER,
//										alert, patient.getPerson(), studyId, pdfBytes, reporFilePath, reportName,excelFileLocalPath,excelBytes);
								emailReportsService.sendReport(p.getPerson(), destFile, ResearchSubjectType.PROVIDER,
										alert, patient.getPerson(), studyId, pdfBytes, reporFilePath, reportName);
								reportEmailed = Boolean.TRUE;
							}
						}
					} catch (Exception e) {
						logger.error(
								"ERROR-PEDIQUEST: An exception has occured while sending a report email to Provider with Id="
										+ p.getId() + e.getMessage());
						logger.error(e.getMessage(), e);
					}
				}
			}

		} catch (Exception e) {
			logger.error("ERROR-PEDIQUEST: An exception has occured while sending report email" + e.getMessage());
			logger.error(e.getMessage(), e);
		}

		return reportEmailed;
	}

	private EmailRecord fetchDataForPainChecklistDomains3(ReportRecord reportData, List<Score> validScores,
			ResearchSubject patientRS, String languageCode) {
		List<PediCTRptSymptomEmailMetadata> symptomlist = (List<PediCTRptSymptomEmailMetadata>) FunctionUtil
				.emptyIfNull(symptomEmailMetadataDao.findAll());
		EmailRecord emailRecord = new EmailRecord();
		Set<PatientSymptomData> patientScores = new HashSet<PatientSymptomData>();
		Map<Integer, Score> scoresInReport = new HashMap<Integer, Score>();
		emailRecord.setScoresInReport(new ArrayList<Score>());
		List<String> symptomsNotPresent = new ArrayList<String>();
		Set<String> newSymptoms = new HashSet<String>();
		Map<Integer, Map<String, Map<String, ScoresDetails>>> validScoresMap = new HashMap<Integer, Map<String, Map<String, ScoresDetails>>>();
		// Map<String, PatientSymptomData> multiLineGraphMap = new HashMap<String,
		// PatientSymptomData>();

		for (Score s : validScores) {
			Map<String, Map<String, ScoresDetails>> sdMap = createScoreDetailsMapForSymptom(s.getScorevalues());
			validScoresMap.put(s.getId(), sdMap);
		}

		logger.debug("Getting bundle for languageCode : " + languageCode);
		ResourceBundle bundle = null;
		bundle = ResourceBundle.getBundle("messages", new Locale(languageCode));
		if (bundle == null) {
			logger.info("bundle not loaded for above languageCode");
			logger.info("So loading for English");
			bundle = ResourceBundle.getBundle("messages", new Locale("en"));
		}

		for (PediCTRptSymptomEmailMetadata symptom : symptomlist) {

			logger.debug("Evaluating when to show for:" + symptom.getAttributeName());
			// check if the symptom was present in last one month

			if (symptom.getBusinessRule() == null) {
				logger.error("No business rule found for msas symtom in CT Report metadata");
				throw new InconsistentDataException();
			}
			logger.debug("Generating points for:" + symptom.getAttributeName());
			PatientSymptomData dataForParent = new PatientSymptomData();
			dataForParent = this.populateFromEmailSymptom(symptom, dataForParent, bundle);
			dataForParent.setSequenceNo(dataForParent.getSequenceNo() + 1);
			dataForParent.setOriginalAttributeName(bundle.getString(symptom.getAttributeName()));
			dataForParent.setAttributeName(symptom.getAttributeName() + "_P");
			dataForParent.setDisplayName(bundle.getString(symptom.getDisplayName()));

			String scoreNameInBusinessRule = symptom.getBusinessRule();
			logger.debug("Plotting graph for" + scoreNameInBusinessRule);
			for (Score s : validScores) {
				List<String> pediSectionsInSurvey = this.getPediSectionsInSurvey(s);

				for (String sectionCode : pediSectionsInSurvey) {
					Boolean isSeveritySet = Boolean.FALSE;
					PatientSymptomData data = null;
					if (parentSections.contains(sectionCode)) {
						data = dataForParent;

					}

					// Data for the most recent survey
					data.setLastSurveyDate(reportData.getLatestQuestInstance().getEndDate());
					Map<String, Map<String, ScoresDetails>> sectionWiseScorevalues = validScoresMap.get(s.getId());
					Map<String, ScoresDetails> scorevalues = sectionWiseScorevalues.get(sectionCode);
					String var = scoreNameInBusinessRule;
					if (scorevalues.containsKey(var)) {
						if (scorevalues.get(var).getValue() != null && scorevalues.get(var).getValue() >= 0) {
							logger.debug("scorevalues.get(var).getValue()" + scorevalues.get(var).getValue());
							logger.debug("data" + data);
							// Add graph point
							SymptomPoints point = new SymptomPoints();
							point.setAttributeName(data.getAttributeName());
							point.setDisplayName(data.getOriginalAttributeName());
							point.setDateReported(s.getQuestInstance().getEndDate());

							if (scorevalues.get(var).getValue() > data.getHighValue())
								point.setValue(data.getHighValue().floatValue());
							else
								point.setValue(scorevalues.get(var).getValue());

//								point.setRespondent(s.getQuestInstance().getResearchSubject().getType().getName());
//													
							data.getSymptompoints().add(point);

							// Create a list of scores used in the report
							if (!scoresInReport.containsKey(s.getId())) {
								scoresInReport.put(s.getId(), s);
								emailRecord.getScoresInReport().add(s);
							}

							data.setLatestScore(Float.toString(scorevalues.get(var).getValue()));

						} else if ((scorevalues.get(var).getValue() == null)
								|| (scorevalues.get(var).getValue() < 0) && !isSeveritySet) {
							data.setLatestScore("NA");
							// data.setLatestSeverity(bundle.getString("report.notanswered"));
							// data.setColorCode("NA");
							// data.setColorCodeValue("NA");
						}
						if (data != null && data.getSymptompoints() != null && !data.getSymptompoints().isEmpty()) {
							logger.debug(data.getSymptompoints().toString());

							// For MSAS symptoms
							// if(symptom.getSymptomType().equals(PediCTReportSymptomType.MSASINDIVIDUAL))

							patientScores.add(data);

						}
					}

				} // Loop for sections in score
					// Add data to report
			} // Loop for scores

		}

		if (!patientScores.isEmpty()) {
			logger.debug(patientScores.toString());
			List<PatientSymptomData> dataList = new ArrayList<PatientSymptomData>();
			dataList.addAll(patientScores);
			Collections.sort(dataList);
			emailRecord.setPatientSymptomData(dataList);
		} else
			emailRecord.setPatientSymptomData(null);
		emailRecord.setSymptomMetadata(symptomlist);
		emailRecord.setSymptomsNotPresent(symptomsNotPresent);
//		reportData.setScoresInReport(new ArrayList<Score>(scoresInReport.values()));

		// Sort report data in order of evaluation time, So that it will be correctly
		// used in Report Summary Section.
		Collections.sort(emailRecord.getScoresInReport(), new ScoreComparator());

		List<String> newSymptomsList = new ArrayList<String>();
		newSymptomsList.addAll(newSymptoms);

		logger.info("Sort new symptom list alphabetically");
		logger.debug("New symptom list before sorting : " + newSymptomsList);
		Collections.sort(newSymptomsList, new Comparator<String>() {
			public int compare(String s1, String s2) {
				return s1.compareToIgnoreCase(s2);
			}
		});

		// TODO : Add other symmptoms list to newSymptomsList here

		logger.debug("New symptom list after sorting : " + newSymptomsList);

		emailRecord.setNewSymptoms(newSymptomsList);
		logger.debug("reportData:" + emailRecord);
		return emailRecord;

	}

	PatientSymptomData populateFromEmailSymptom(PediCTRptSymptomEmailMetadata symptom, PatientSymptomData data,
			ResourceBundle bundle) {

		data.setLatestScore("NA");

		data.setHighValue(symptom.getHighValue());
		data.setLowValue(symptom.getLowValue());

		data.setScale(symptom.getScale());
		data.setSequenceNo(symptom.getSequenceNo() * 100);
		data.setSymptompoints(new ArrayList<SymptomPoints>());

		data.setAttributeName(bundle.getString(symptom.getAttributeName()));

		return data;

	}

	// delete NCCPC-R scoring rule 7/3/24
//	String createAndLoadExcelsheetForNCCCPC_R(EmailRecord emailRecord,String forEmailreportName,String languageCode)
	void createAndLoadExcelsheetForNCCCPC_R(EmailRecord emailRecord, String forEmailreportName, String languageCode) {
		logger.trace("In generateMRAReport.");
		// delete NCCPC-R scoring rule 7/3/24
		// String excelFileLocalPath=null;

		String errorMsg = "";

		try {
			Study study = studyDao.findByStudyId(1);
			logger.debug("StudyName:" + study.getStudyName());

			if (study != null && study.getStudyStartDate() != null) {

				File directory = null;
				String mainDirectory = ctReportExcelFileBasePath;
				// + queue.getOriginalTicketNo();
				logger.trace("Creating Directory main Export Directory: " + mainDirectory);
				directory = new File(mainDirectory);
				directory.mkdir();

				// delete NCCPC-R score rule 7/3/24
//				List<NCCCPC_R_Content> NCCCPC_R_List = getNCCCPC_RInfo(emailRecord);
				// logger.debug("# diseaseStatus found:");

				// try {
				// PopulateNCCCPC_R Info Sheet.
				// populateNCCCPC_RInfoSheet(NCCCPC_R_List, directory,languageCode);

				// } catch (IOException e) {

				// errorMsg = e.getMessage();

				// logger.error(e.getMessage(), e);
				// }
				String currDateString = getCurrentDateInString("MM_dd_yyyy");
				// Add all csv files in Excelsheet.
				// excelFileLocalPath = directory.toString() + "CTReport_" + currDateString +
				// ".xlsx";

				// delete NCCPC-R scoring rule 7/3/24
				// excelFileLocalPath = directory.toString()+"\\" + "CTReport_"
				// +forEmailreportName + ".xlsx";
				// logger.debug("Excel File Local Path: " + excelFileLocalPath);

				logger.debug("mergingCSVIntoExcel.");
				try {
					// delete NCCPC-R scoring rule 7/3/24
//					this.mergeCSVIntoExcel(mainDirectory, excelFileLocalPath);
					this.mergeCSVIntoExcel(mainDirectory);
				} catch (Exception e) {

					errorMsg = e.getMessage();

					logger.error(e.getMessage(), e);
				}

			}
		} catch (Exception e) {

			logger.error(e.getMessage(), e);
			errorMsg = e.getMessage();

		}
		// delete NCCPC-R scoring rule 7/3/24
		// return excelFileLocalPath;
	}

	private String getCurrentDateInString(String pattern) {
		if (pattern == null || pattern.isEmpty())
			pattern = "MM_dd_yyyy";
		SimpleDateFormat formatter = new SimpleDateFormat(pattern);
		String currrDate = formatter.format(new Date());
		return currrDate;
	}

	// delete NCCPC-R scoring rule
//	private void mergeCSVIntoExcel(String mainDirectory, String excelFileLocalPath) {
	private void mergeCSVIntoExcel(String mainDirectory) {
		List<String> results = new ArrayList<String>();
		File[] files = new File(mainDirectory).listFiles();
		for (File file : files) {
			if (file.isFile()) {

				results.add(file.getAbsolutePath());
			}
		}
		int size = results.size();

		Workbook workBook = new XSSFWorkbook();

		// HSSFWorkbook workBook = new HSSFWorkbook();
		for (int i = 0; i < size; i++) {
			Path p = Paths.get(results.get(i).toString());
			String file = p.getFileName().toString();
			// File name split by '.' for get name and type of file.
			String[] values = null;
			if (file != null) {
				values = file.split("\\.");
			}
			if (values != null) {
				String name = values[0];
				String type = values[1];
				logger.debug("CSV file Name: " + name + ", Type: " + type);
				if (!type.equals("xlsx"))
					// delete NCCPC-R scoring rule 7/3/24
//					this.csvToXLSX(workBook, results.get(i).toString(), name, excelFileLocalPath);
					this.csvToXLSX(workBook, results.get(i).toString(), name);
			}
		}

	}

	// delete NCCPC-R scoring rule 7/3/24
//	private void csvToXLSX(Workbook workBook, String filename, String sheetName, String excelFileLocalPath) {
	private void csvToXLSX(Workbook workBook, String filename, String sheetName) {
		logger.trace("Inside csvToXLSX method.");
		// delete NCCPC-R scoring rule 7/3/24
//		logger.debug("FileName: " + filename + ", SheetName: " + "excelFileLocalPath: " + excelFileLocalPath);
		logger.debug("FileName: " + filename);
		try {
			String csvFile = filename; // csv file address
//			String excelFileLocalPath = reportFile.toString() + "/MRAReport.xls"; // xlsx file address
			// HSSFWorkbook workBook = new HSSFWorkbook();
			// HSSFSheet sheet = workBook.createSheet(sheetName);

			Sheet sheet = workBook.createSheet(sheetName);

			String currentLine = null;
			int RowNum = 0;
			BufferedReader br = new BufferedReader(new FileReader(csvFile));
			while ((currentLine = br.readLine()) != null) {
				String str[] = currentLine.split(",");
				// HSSFRow currentRow = sheet.createRow(RowNum);
				Row currentRow = sheet.createRow(RowNum);
				RowNum++;
				for (int i = 0; i < str.length; i++) {
					currentRow.createCell(i).setCellValue(str[i]);
				}
			}
			br.close();
			// delete NCCPC-R scoring rule 7/3/24
			// FileOutputStream fileOutputStream = new FileOutputStream(excelFileLocalPath);
			// workBook.write(fileOutputStream);
			// fileOutputStream.close();

			File file = new File(filename);
			file.delete();
			logger.debug("csvToXLSX Success.");
//			System.out.println("Done");
		} catch (Exception ex) {
			logger.error(ex.getMessage(), ex);
		}

	}
	/*
	 * List<NCCCPC_R_Content> getNCCCPC_RInfo(EmailRecord emailRecord) {
	 * List<NCCCPC_R_Content> list_NCCCPC_R =new ArrayList<NCCCPC_R_Content>();
	 * 
	 * for(int i =0 ; i<emailRecord.getPatientSymptomData().size();i++) {
	 * NCCCPC_R_Content setData=new NCCCPC_R_Content();
	 * setData.setDisplayName(emailRecord.getPatientSymptomData().get(i).
	 * getDisplayName());
	 * setData.setRange(emailRecord.getPatientSymptomData().get(i).getScale()); //
	 * float[] valueArray = new
	 * float[emailRecord.getPatientSymptomData().get(i).getSymptompoints().size()];
	 * List<Float> floatList=new ArrayList<Float>(); for (int j = 0; j <
	 * emailRecord.getPatientSymptomData().get(i).getSymptompoints().size(); j++) {
	 * 
	 * float value =
	 * emailRecord.getPatientSymptomData().get(i).getSymptompoints().get(j).getValue
	 * (); // Assign the float value to the desired index of the array //
	 * valueArray[j] = value; // setData.setValue(valueArray); floatList.add(value);
	 * setData.setFloatValue(floatList);
	 * 
	 * } setData.setCurrentScoreValue(emailRecord.getPatientSymptomData().get(i).
	 * getLatestScore()); list_NCCCPC_R.add(setData); } return list_NCCCPC_R; }
	 */

	// delete NCCPC-R score rule 7/3/24
//	List<NCCCPC_R_Content> getNCCCPC_RInfo(EmailRecord emailRecord)
//	{
//		List<NCCCPC_R_Content> list_NCCCPC_R =new  ArrayList<NCCCPC_R_Content>();
//		
//		for(int i =0  ; i<emailRecord.getPatientSymptomData().size();i++)
//		{
//			NCCCPC_R_Content  setData=new NCCCPC_R_Content();
//			Object[] valueArr=new Object[emailRecord.getPatientSymptomData().get(i).getSymptompoints().size()] ;
//			List<Object[]> valueList = new ArrayList<Object[]>(); 
//			List<Object[]> dateReportedList = new ArrayList<Object[]>(); 
//			Date[] dateReportedArr=new Date[emailRecord.getPatientSymptomData().get(i).getSymptompoints().size()] ;
//			
//			setData.setDisplayName(emailRecord.getPatientSymptomData().get(i).getDisplayName());		
//			setData.setRange(emailRecord.getPatientSymptomData().get(i).getScale());
//			
//			for (int j = 0; j < emailRecord.getPatientSymptomData().get(i).getSymptompoints().size(); j++) {
//				
//				float value = emailRecord.getPatientSymptomData().get(i).getSymptompoints().get(j).getValue();
//				valueArr[j]=value;
//				Date dateReported = emailRecord.getPatientSymptomData().get(i).getSymptompoints().get(j).getDateReported();
//				dateReportedArr[j]=dateReported;
//			}
//			
//	
//			valueList.add(valueArr);
//			dateReportedList.add(dateReportedArr);
//		      for(Object[] ds :valueList)
//		      {  
//		      	 if ( ds.length > 0   && ds[0] != null  )
//		    		  setData.setColumn1(ds[0].toString().replace(",", " |"));
//		      	 else
//		      		setData.setColumn1(" ");
//					if (ds.length > 1  && ds[1] != null  )
//						setData.setColumn2(ds[1].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn2(" ");
//					if (ds.length > 2 && ds[2] != null )
//						setData.setColumn3(ds[2].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn3(" ");
//					if (ds.length > 3 && ds[3] != null )
//						setData.setColumn4(ds[3].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn4(" ");
//					if (ds.length > 4 && ds[4] != null )
//						setData.setColumn5(ds[4].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn5(" ");
//					if (ds.length > 5 && ds[5] != null )
//						setData.setColumn6(ds[5].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn6(" ");
//					if (ds.length > 6 && ds[6] != null )
//						setData.setColumn7(ds[6].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn7(" ");
//					if (ds.length > 7 && ds[7] != null )
//						setData.setColumn8(ds[7].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn8(" ");
//					if (ds.length > 8 && ds[8] != null)
//						setData.setColumn9(ds[8].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn9(" ");
//					if (ds.length > 9 && ds[9] != null )
//						setData.setColumn10(ds[9].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn10(" ");
//					if (ds.length > 10 && ds[10] != null )
//						setData.setColumn11(ds[10].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn11(" ");
//					if (ds.length > 11 && ds[11] != null )
//						setData.setColumn12(ds[11].toString().replace(",", " |"));
//					 else
//				      		setData.setColumn12(" ");
//		    	 
//		      }
//		      for(Object[] ds :dateReportedList)
//		      {
//		    	
//		    	  if (ds.length > 0 && ds[0] != null )
//		    		  setData.setDateReported1(ds[0].toString().replace(",", " |"));
//		    	  else
//		    		  setData.setDateReported1(" ");
//		    	  
//					if (ds.length > 1 && ds[1] != null  )
//						setData.setDateReported2(ds[1].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported2(" ");
//		
//					if ( ds.length > 2 && ds[2] != null )
//						setData.setDateReported3(ds[2].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported3(" ");
//					if (ds.length > 3 && ds[3] != null )
//						setData.setDateReported4(ds[3].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported4(" ");
//					if (ds.length > 4 && ds[4] != null)
//						setData.setDateReported5(ds[4].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported5(" ");
//					if (ds.length > 5 && ds[5] != null )
//						setData.setDateReported6(ds[5].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported6(" ");
//					if (ds.length > 6 && ds[6] != null)
//						setData.setDateReported7(ds[6].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported7(" ");
//					if (ds.length > 7 && ds[7] != null )
//						setData.setDateReported8(ds[7].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported8(" ");
//					if (ds.length > 8 && ds[8] != null )
//						setData.setDateReported9(ds[8].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported9(" ");
//					if (ds.length > 9 && ds[9] != null )
//						setData.setDateReported10(ds[9].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported10(" ");
//					if (ds.length > 10 && ds[10] != null )
//						setData.setDateReported11(ds[10].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported11(" ");
//					if (ds.length > 11  && ds[11] != null )
//						setData.setDateReported12(ds[11].toString().replace(",", " |"));
//					 else
//			    		  setData.setDateReported12(" ");
//		    	  }
//					
//		      
//				
//			    setData.setLastSurveyDate(emailRecord.getPatientSymptomData().get(i).getLastSurveyDate().toString());
//				setData.setCurrentScoreValue(emailRecord.getPatientSymptomData().get(i).getLatestScore());
//			//	setData.setDateReported(dateReportedArr);
//				list_NCCCPC_R.add(setData);
//		
//	}
//		return list_NCCCPC_R;
//	}
	public void populateNCCCPC_RInfoSheet(List<NCCCPC_R_Content> NCCCPC_R_List, File directory, String languageCode)
			throws IOException {
		logger.trace("In populateNCCCPC_RInfoSheet.");
		// name of generated csv
		final String CSV_LOCATION = "painChecklistDomains3.csv";
		FileWriter writer = null;
		try {
			Path filePath = Paths.get(directory.toString() + File.separatorChar + "painChecklistDomains3.csv");
			Files.deleteIfExists(filePath);
			new FilePermission(filePath.toString() + File.separatorChar + "*", "read,write,execute");
			File file = new File(filePath.toUri());
			file.getParentFile().mkdirs();
			file.createNewFile();

			// Creating writer class to generate
			// csv file
			writer = new FileWriter(file);
			// Create Mapping Strategy to arrange the column name in order

			ColumnPositionMappingStrategy<NCCCPC_R_Content> mappingStrategy = new ColumnPositionMappingStrategy<NCCCPC_R_Content>();

			/*
			 * CustomMappingStrategy<PersonalInfoForMemberExport> mappingStrategy= new
			 * CustomMappingStrategy<PersonalInfoForMemberExport>();
			 */
			mappingStrategy.setType(NCCCPC_R_Content.class);

			// Arrange column name as provided in below array.
			// String[] columns = new String[] { "displayName", "Range", "", "", "","", "",
			// "", "", "","","","","", "date" };

			String[] columns = new String[] { "displayName", "Range", "column1", "column2", "column3", "column4",
					"column5", "column6", "column7", "column8", "column9", "column10", "column11", "column12",
					"currentScoreValue" };
			mappingStrategy.setColumnMapping(columns);

			// Creating StatefulBeanToCsv object
			StatefulBeanToCsvBuilder<NCCCPC_R_Content> builder = new StatefulBeanToCsvBuilder<NCCCPC_R_Content>(writer);
			builder.withQuotechar(CSVWriter.NO_QUOTE_CHARACTER).withEscapechar(CSVWriter.NO_ESCAPE_CHARACTER)
					.withMappingStrategy(mappingStrategy);

			StatefulBeanToCsv<NCCCPC_R_Content> beanWriter = builder.build();
			String str = null;

			// DateFormat dateFormat = new SimpleDateFormat("yyyy-mm-dd hh:mm:ss");
			String str0 = NCCCPC_R_List.get(0).getDateReported1();
			String str1 = NCCCPC_R_List.get(0).getDateReported2();
			String str2 = NCCCPC_R_List.get(0).getDateReported3();
			String str3 = NCCCPC_R_List.get(0).getDateReported4();
			String str4 = NCCCPC_R_List.get(0).getDateReported5();
			String str5 = NCCCPC_R_List.get(0).getDateReported6();
			String str6 = NCCCPC_R_List.get(0).getDateReported7();
			String str7 = NCCCPC_R_List.get(0).getDateReported8();
			String str8 = NCCCPC_R_List.get(0).getDateReported9();
			String str9 = NCCCPC_R_List.get(0).getDateReported10();
			String str10 = NCCCPC_R_List.get(0).getDateReported11();
			String str11 = NCCCPC_R_List.get(0).getDateReported12();
			String lastSurveyDate = NCCCPC_R_List.get(0).getLastSurveyDate();

			String firstHeader = "" + "," + "" + "," + "" + "," + "" + "," + "" + "," + "" + "," + "" + "," + "" + ","
					+ "" + "," + "" + "," + "" + "," + "" + "," + "" + "," + "" + "," + "current \n";
			// str ="PainChecklistDomains3 ," + "Range ," + str0 +"," + str1 +"," + str2
			// +","+ str3 +","+ str4 +","+ str5 +","+ str6+"," + str7+"," + str8+"," + str9
			// +","+ str10+"," + str11 +","+ lastSurveyDate+ "\n";
			// ResourceBundle bundle = ResourceBundle.getBundle("messages", new
			// Locale(languageCode));
			// String pain_checklist_domains3 = bundle.getString("pain_checklist_domains3");
			// String range = bundle.getString("pain_checklist_range");
			if (languageCode.equals("en")) {
				str = "Pain Checklist Domains3 ," + "Range ," + str0 + "," + str1 + "," + str2 + "," + str3 + "," + str4
						+ "," + str5 + "," + str6 + "," + str7 + "," + str8 + "," + str9 + "," + str10 + "," + str11
						+ "," + lastSurveyDate + "\n";
			} else if (languageCode.equals("es")) {
				str = "Dominios Dolor-Checklis3 ," + "Rango ," + str0 + "," + str1 + "," + str2 + "," + str3 + ","
						+ str4 + "," + str5 + "," + str6 + "," + str7 + "," + str8 + "," + str9 + "," + str10 + ","
						+ str11 + "," + lastSurveyDate + "\n";
			}
			writer.append(firstHeader);
			writer.append(str);

			// writer.append("PainChecklistDomains3 , Range,column1,column2 ,
			// column3,column4 ,column5 , column6,column7 ,column8 , column9,
			// column10,column11 , column12, currentScoreValue \n");

			// Write list to StatefulBeanToCsv object

			beanWriter.write(NCCCPC_R_List);

		} catch (Exception e) {
			logger.error(e.getMessage(), e);
		} finally {
			// closing the writer object
			writer.close();
		}

	}
	/*
	 * private boolean checkDistressEpisodeAboveThreshold(QuestionnaireInstance
	 * questInstance) { List<PediScore> pediScores =
	 * pediScoreDao.findPediScoreForQuestionniareInstance(questInstance.getId());
	 * 
	 * if(pediScores.size()>1) {
	 * logger.debug("More than one scores found for the survey: "+questInstance.
	 * getId()); throw new InconsistentDataException(); } if(pediScores.isEmpty()) {
	 * logger.debug("No scores found for the survey: "+questInstance.getId()); throw
	 * new InconsistentDataException(); } PediScore pediScore = pediScores.get(0);
	 * String questionnaireCode =
	 * questInstance.getQuestionnaire().getHl7Entity().getCode(); String
	 * msasDistressScore = ""; String pedsqlDistressScore = ""; float threshold = 0;
	 * 
	 * if(questionnaireCode.equalsIgnoreCase("PQ2-4")) { msasDistressScore =
	 * "msas_total_pf"; pedsqlDistressScore = "pql_total_2-4"; threshold = (float)
	 * 3.2; return checkIfScoreExceedsThreshold(pediScore, msasDistressScore,
	 * pedsqlDistressScore, threshold); } else
	 * if(questionnaireCode.equalsIgnoreCase("PQ5-6")) { msasDistressScore =
	 * "msas_total_pf"; threshold = (float) 3.2; //Depending on who will answer:
	 * Child or Parent Answer answer =
	 * questInstanceService.getLatestAnswerforQuestion(questInstance,questionService
	 * .getQuestionByCode("who_resp",1));
	 * 
	 * String answerAbbrev =
	 * answer.getOptionChoosen().iterator().next().getAoAbbrev();
	 * 
	 * if(answerAbbrev.equals("who_resp_1")) { pedsqlDistressScore =
	 * "pql_total_5-7"; } else if(answerAbbrev.equals("who_resp_2")) {
	 * pedsqlDistressScore = "pql_total_5-7_p"; }
	 * 
	 * return checkIfScoreExceedsThreshold(pediScore, msasDistressScore,
	 * pedsqlDistressScore, threshold); } else
	 * if(questionnaireCode.equalsIgnoreCase("PQ7")) { msasDistressScore =
	 * "msas_total_pf"; threshold = (float) 3.2;
	 * 
	 * //Depending on who will answer: Child or Parent Answer answer =
	 * questInstanceService.getLatestAnswerforQuestion(questInstance,questionService
	 * .getQuestionByCode("who_resp",1));
	 * 
	 * String answerAbbrev =
	 * answer.getOptionChoosen().iterator().next().getAoAbbrev();
	 * 
	 * if(answerAbbrev.equals("who_resp_1")) { msasDistressScore = "msasyc_total";
	 * pedsqlDistressScore = "pql_total_5-7"; threshold = (float) 9; } else
	 * if(answerAbbrev.equals("who_resp_2")) { pedsqlDistressScore =
	 * "pql_total_5-7_p"; } return checkIfScoreExceedsThreshold(pediScore,
	 * msasDistressScore, pedsqlDistressScore, threshold); } else
	 * if(questionnaireCode.equalsIgnoreCase("PQ8-12") ||
	 * (questionnaireCode.equalsIgnoreCase("PQ8-12p"))) { //For either
	 * questionnaire, the questionnaire instance has been invoked //because the
	 * status is SATISFIESMSASCRITERIA //At this point, the score for this
	 * questionnaire instance will contain both //the scores i.e. MSASyc and MSASpf
	 * //MSASyc is given the first preference //If MSASyc scores have crossed the
	 * threshold consider yc else check if MSASpf //has crossed the threshold or not
	 * msasDistressScore = "msasyc_total"; pedsqlDistressScore = "pql_total_8-12";
	 * threshold = (float) 9;
	 * 
	 * boolean check = checkIfScoreExceedsThreshold(pediScore, msasDistressScore,
	 * pedsqlDistressScore, threshold); if(!check) { msasDistressScore =
	 * "msas_total_pf"; pedsqlDistressScore = "pql_total_8-12_p"; threshold =
	 * (float) 3.2;
	 * 
	 * check = checkIfScoreExceedsThreshold(pediScore, msasDistressScore,
	 * pedsqlDistressScore, threshold); } return check;
	 * 
	 * } else if(questionnaireCode.equalsIgnoreCase("PQ13plus")) { msasDistressScore
	 * = "msas_total_oc"; pedsqlDistressScore = "pql_total_13-18"; threshold =
	 * (float) 3.2; return checkIfScoreExceedsThreshold(pediScore,
	 * msasDistressScore, pedsqlDistressScore, threshold); } else
	 * if(questionnaireCode.equalsIgnoreCase("PQ13plusp")) { msasDistressScore =
	 * "msas_total_p13"; pedsqlDistressScore = "pql_total_13-18_p"; threshold =
	 * (float) 3.2; return checkIfScoreExceedsThreshold(pediScore,
	 * msasDistressScore, pedsqlDistressScore, threshold); } return false; }
	 */

	/*
	 * private boolean checkIfScoreExceedsThreshold(PediScore pediScore,String
	 * msasDistressScore,String pedsqlDistressScore, float threshold) {
	 * ScoresDetails msasTotal = getScoresDetails(pediScore, msasDistressScore);
	 * ScoresDetails pedSqlTotal = getScoresDetails(pediScore, pedsqlDistressScore);
	 * if(msasTotal == null || pedSqlTotal == null) { return false; }
	 * if(msasTotal.getValue() != null) { if(msasTotal.getValue() >= threshold) {
	 * return true; } } if( pedSqlTotal.getValue() != null) {
	 * if(pedSqlTotal.getValue() <= 60) { return true; } } return false; }
	 */

	/*
	 * private ScoresDetails getScoresDetails(PediScore pediScore, String scoreName)
	 * { for(ScoresDetails sd:pediScore.getScore().getScorevalues()) { if
	 * (sd.getScoreName().compareTo(scoreName)==0) return sd; } return null;
	 * 
	 * }
	 */
	/**
	 * 
	 * @param answer
	 * @return
	 */
	/*
	 * private String getEnglishAnswerText(Answer answer) { if(answer!=null &&
	 * answer.getOptionChoosen()!=null) { for(AnswerOption answerOption
	 * :answer.getOptionChoosen()) { for(AnswerOptionContent answerOptionContent :
	 * answerOption.getAnswerOptionContents()) {
	 * if(answerOptionContent.getLanguage().equalsIgnoreCase("en")) { return
	 * answerOptionContent.getAnswerText().toLowerCase(); } } } } return null; }
	 */
}
